import {CallExpression, Expression, Node, NodeArray, Statement, SyntaxKind} from "typescript";
import {isIdentifierObject} from "../predicate/PredicateFunctions";
import {allIdentifiersGetter, arrowFunctionGetter, callExpressionGetter, childStatementGetter, classDeclarationGetter, enumDeclarationGetter, exportDeclarationGetter, filePathUtil, functionDeclarationGetter, importDeclarationGetter, languageService, mutationGetter, newExpressionGetter, resolvedIdentifierValueGetter, resolvedSerializedIdentifierValueGetter, variableDeclarationGetter} from "../services";
import {ICodeAnalyzer, ICodeAnalyzerConstructorOptions} from "./interface/ICodeAnalyzer";
import {IArrowFunction, ICallExpression, IClassIndexer, IEnumIndexer, IExportDeclaration, IFunctionIndexer, IIdentifierMap, IImportDeclaration, IMutationDeclaration, INewExpression, IResolvedIIdentifierValueMap, IResolvedSerializedIIdentifierValueMap, IVariableIndexer} from "../identifier/interface/IIdentifier";

/**
 * A service that parses and reflects on the AST generated by Typescript's language service.
 * With it, we can extract metadata such as initialization values and types, arguments and import
 * declarations.
 * @author Frederik Wessberg
 */
export class CodeAnalyzer implements ICodeAnalyzer {

	constructor (options?: ICodeAnalyzerConstructorOptions) {
		if (options != null) this.excludeFiles(options.excludeFiles);
	}

	public excludeFiles (match: RegExp|RegExp[]|Set<RegExp>): void {
		filePathUtil.exclude(match);
	}

	public addFile (fileName: string, content: string, version?: number): NodeArray<Statement> {
		return languageService.addFile(fileName, content, version);
	}

	public getExportDeclarationsForFile (fileName: string, deep: boolean = false): IExportDeclaration[] {
		return exportDeclarationGetter.getForFile(fileName, deep);
	}

	public getExportDeclarations (statements: string|(Statement|Expression|Node)[], deep: boolean = false): IExportDeclaration[] {
		const actualStatements = typeof statements === "string" ? languageService.toAST(statements) : statements;
		return exportDeclarationGetter.getForStatements(actualStatements, deep);
	}

	/**
	 * Gets and formats all CallExpressions associated with the given file.
	 * These hold information such as the arguments the members are invoked with, generic type
	 * arguments and such.
	 * @param {string} fileName
	 * @param {boolean} [deep=false]
	 * @returns {ICallExpression[]}
	 */
	public getCallExpressionsForFile (fileName: string, deep: boolean = false): ICallExpression[] {
		return callExpressionGetter.getForFile(fileName, deep);
	}

	/**
	 * Returns true if the given array of statements contains at least statement of the given kind.
	 * @param {(Statement|Expression|Node)[]} statements
	 * @param {SyntaxKind} kind
	 * @param {boolean} [deep=false]
	 * @returns {boolean}
	 */
	public statementsIncludeKind (statements: (Statement|Expression|Node)[], kind: SyntaxKind, deep: boolean = false): boolean {
		for (const statement of statements) {
			if (statement.kind === kind) return true;
			if (deep) {
				const childMatch = this.statementsIncludeKind(childStatementGetter.get(statement), kind, deep);
				if (childMatch) return true;
			}
		}
		return false;
	}

	/**
	 * Gets and formats all CallExpressions associated with the given statements.
	 * These hold information such as the arguments the members are invoked with, generic type
	 * arguments and such.
	 * @param {string|(Statement|Expression|Node)[]} statements
	 * @param {boolean} [deep=false]
	 * @returns {ICallExpression[]}
	 */
	public getCallExpressions (statements: string|(Statement|Expression|Node)[], deep: boolean = false): ICallExpression[] {
		const actualStatements = typeof statements === "string" ? languageService.toAST(statements) : statements;
		return callExpressionGetter.getForStatements(actualStatements, deep);
	}

	/**
	 * Gets and formats all NewExpressions associated with the given file.
	 * These hold information such as the arguments the constructor is invoked with, generic type
	 * arguments and such.
	 * @param {string} fileName
	 * @param {boolean} [deep=false]
	 * @returns {INewExpression[]}
	 */
	public getNewExpressionsForFile (fileName: string, deep: boolean = false): INewExpression[] {
		return newExpressionGetter.getForFile(fileName, deep);
	}

	/**
	 * Gets and formats all NewExpressions associated with the given statements.
	 * These hold information such as the arguments the constructor is invoked with, generic type
	 * arguments and such.
	 * @param {string|(Statement|Expression|Node)[]} statements
	 * @param {boolean} [deep=false]
	 * @returns {INewExpression[]}
	 */
	public getNewExpressions (statements: string|(Statement|Expression|Node)[], deep: boolean = false): INewExpression[] {
		const actualStatements = typeof statements === "string" ? languageService.toAST(statements) : statements;
		return newExpressionGetter.getForStatements(actualStatements, deep);
	}

	/**
	 * Gets a map of all identifiers for the given file and their resolved serialized values.
	 * @param {string} fileName
	 * @param {boolean} [deep=false]
	 * @returns {IResolvedSerializedIIdentifierValueMap}
	 */
	public getResolvedSerializedIdentifierValuesForFile (fileName: string, deep: boolean = false): IResolvedSerializedIIdentifierValueMap {
		return resolvedSerializedIdentifierValueGetter.getForFile(fileName, deep);
	}

	/**
	 * Gets a map of all identifiers for the given statements and their resolved serialized values.
	 * @param {string|(Statement|Expression|Node)[]} statements
	 * @param {boolean} [deep=false]
	 * @returns {IResolvedSerializedIIdentifierValueMap}
	 */
	public getResolvedSerializedIdentifierValues (statements: string|(Statement|Expression|Node)[], deep: boolean = false): IResolvedSerializedIIdentifierValueMap {
		const actualStatements = typeof statements === "string" ? languageService.toAST(statements) : statements;
		return resolvedSerializedIdentifierValueGetter.getForStatements(actualStatements, deep);
	}

	/**
	 * Gets a map of all identifiers for the given file and their resolved values.
	 * @param {string} fileName
	 * @param {boolean} [deep=false]
	 * @returns {IResolvedIIdentifierValueMap}
	 */
	public getResolvedIdentifierValuesForFile (fileName: string, deep: boolean = false): IResolvedIIdentifierValueMap {
		return resolvedIdentifierValueGetter.getForFile(fileName, deep);
	}

	/**
	 * Gets a map of all identifiers for the given statements and their resolved values.
	 * @param {string|(Statement|Expression|Node)[]} statements
	 * @param {boolean} [deep=false]
	 * @returns {IResolvedIIdentifierValueMap}
	 */
	public getResolvedIdentifierValues (statements: string|(Statement|Expression|Node)[], deep: boolean = false): IResolvedIIdentifierValueMap {
		const actualStatements = typeof statements === "string" ? languageService.toAST(statements) : statements;
		return resolvedIdentifierValueGetter.getForStatements(actualStatements, deep);
	}

	/**
	 * Gets all function declarations (if any) that occurs in the given file
	 * and returns them in a IFunctionIndexer. If 'deep' is true, it will walk through the Statements recursively.
	 * @param {string} fileName
	 * @param {boolean} [deep=false]
	 * @returns {IFunctionIndexer}
	 */
	public getFunctionDeclarationsForFile (fileName: string, deep: boolean = false): IFunctionIndexer {
		return functionDeclarationGetter.getForFile(fileName, deep);
	}

	/**
	 * Gets all function declarations (if any) that occurs in the given array of statements
	 * and returns them in a IFunctionIndexer. If 'deep' is true, it will walk through the Statements recursively.
	 * @param {string|(Statement|Expression|Node)[]} statements
	 * @param {boolean} [deep=false]
	 * @returns {IFunctionIndexer}
	 */
	public getFunctionDeclarations (statements: string|(Statement|Expression|Node)[], deep: boolean = false): IFunctionIndexer {
		const actualStatements = typeof statements === "string" ? languageService.toAST(statements) : statements;
		return functionDeclarationGetter.getForStatements(actualStatements, deep);
	}

	/**
	 * Gets all enum declarations (if any) that occurs in the given file
	 * and returns them in a IEnumIndexer. If 'deep' is true, it will walk through the Statements recursively.
	 * @param {string} fileName
	 * @param {boolean} [deep=false]
	 * @returns {IEnumIndexer}
	 */
	public getEnumDeclarationsForFile (fileName: string, deep: boolean = false): IEnumIndexer {
		return enumDeclarationGetter.getForFile(fileName, deep);
	}

	/**
	 * Gets all enum declarations (if any) that occurs in the given array of statements
	 * and returns them in a IEnumIndexer. If 'deep' is true, it will walk through the Statements recursively.
	 * @param {string|(Statement|Expression|Node)[]} statements
	 * @param {boolean} [deep=false]
	 * @returns {IEnumIndexer}
	 */
	public getEnumDeclarations (statements: string|(Statement|Expression|Node)[], deep: boolean = false): IEnumIndexer {
		const actualStatements = typeof statements === "string" ? languageService.toAST(statements) : statements;
		return enumDeclarationGetter.getForStatements(actualStatements, deep);
	}

	/**
	 * Gets all identifiers (such as variables, functions, classes, enums, imports, exports, etc) (if any) that occurs in the given file
	 * and returns them in a IVariableIndexer. If 'deep' is true, it will walk through the Statements recursively.
	 * @param {string} fileName
	 * @param {boolean} [deep=false]
	 * @returns {IIdentifierMap}
	 */
	public getAllIdentifiersForFile (fileName: string, deep: boolean = false): IIdentifierMap {
		return allIdentifiersGetter.getForFile(fileName, deep);
	}

	/**
	 * Gets all identifiers (such as variables, functions, classes, enums, imports, exports, etc) (if any) that occurs in the given array of statements
	 * and returns them in a IIdentifierMap. If 'deep' is true, it will walk through the Statements recursively.
	 * @param {string|(Statement|Expression|Node)[]} statements
	 * @param {boolean} [deep=false]
	 * @returns {IIdentifierMap}
	 */
	public getAllIdentifiers (statements: string|(Statement|Expression|Node)[], deep: boolean = false): IIdentifierMap {
		const actualStatements = typeof statements === "string" ? languageService.toAST(statements) : statements;
		return allIdentifiersGetter.getForStatements(actualStatements, deep);
	}

	/**
	 * Gets all variable assignments (if any) that occurs in the given file
	 * and returns them in a IVariableIndexer. If 'deep' is true, it will walk through the Statements recursively.
	 * @param {string} fileName
	 * @param {boolean} [deep=false]
	 * @returns {IVariableIndexer}
	 */
	public getVariableDeclarationsForFile (fileName: string, deep: boolean = false): IVariableIndexer {
		return variableDeclarationGetter.getForFile(fileName, deep);
	}

	/**
	 * Gets all variable assignments (if any) that occurs in the given array of statements
	 * and returns them in a IVariableIndexer. If 'deep' is true, it will walk through the Statements recursively.
	 * @param {string|(Statement|Expression|Node)[]} statements
	 * @param {boolean} [deep=false]
	 * @returns {IVariableIndexer}
	 */
	public getVariableDeclarations (statements: string|(Statement|Expression|Node)[], deep: boolean = false): IVariableIndexer {
		const actualStatements = typeof statements === "string" ? languageService.toAST(statements) : statements;
		return variableDeclarationGetter.getForStatements(actualStatements, deep);
	}

	/**
	 * Gets all class declarations (if any) that occurs in the given file
	 * and returns them as a IClassIndexer.
	 * @param {string} fileName
	 * @param {boolean} [deep=false]
	 * @returns {IClassIndexer}
	 */
	public getClassDeclarationsForFile (fileName: string, deep: boolean = false): IClassIndexer {
		return classDeclarationGetter.getForFile(fileName, deep);
	}

	/**
	 * Gets all class declarations (if any) that occurs in the given array of statements
	 * and returns them as a IClassIndexer.
	 * @param {string|(Statement|Expression|Node)[]} statements
	 * @param {boolean} [deep=false]
	 * @returns {IClassIndexer}
	 */
	public getClassDeclarations (statements: string|(Statement|Expression|Node)[], deep: boolean = false): IClassIndexer {
		const actualStatements = typeof statements === "string" ? languageService.toAST(statements) : statements;
		return classDeclarationGetter.getForStatements(actualStatements, deep);
	}

	/**
	 * Gets and returns all ArrowFunctions (if any) that occur in the given file
	 * @param {string} fileName
	 * @param {boolean} [deep=false]
	 * @returns {IArrowFunction[]}
	 */
	public getArrowFunctionsForFile (fileName: string, deep: boolean = false): IArrowFunction[] {
		return arrowFunctionGetter.getForFile(fileName, deep);
	}

	/**
	 * Gets and returns all ArrowFunctions (if any) that occur in the given array of statements.
	 * @param {string|(Statement|Expression|Node)[]} statements
	 * @param {boolean} [deep=false]
	 * @returns {IArrowFunction[]}
	 */
	public getArrowFunctions (statements: string|(Statement|Expression|Node)[], deep: boolean = false): IArrowFunction[] {
		const actualStatements = typeof statements === "string" ? languageService.toAST(statements) : statements;
		return arrowFunctionGetter.getForStatements(actualStatements, deep);
	}

	/**
	 * Gets and returns all ImportDeclarations (if any) that occur in the given file
	 * @param {string} fileName
	 * @param {boolean} [deep=false]
	 * @returns {IImportDeclaration[]}
	 */
	public getImportDeclarationsForFile (fileName: string, deep: boolean = false): IImportDeclaration[] {
		return importDeclarationGetter.getForFile(fileName, deep);
	}

	/**
	 * Gets and returns all ImportDeclarations (if any) that occur in the given array of statements.
	 * @param {string|(Statement|Expression|Node)[]} statements
	 * @param {boolean} [deep=false]
	 * @returns {IImportDeclaration[]}
	 */
	public getImportDeclarations (statements: string|(Statement|Expression|Node)[], deep: boolean = false): IImportDeclaration[] {
		const actualStatements = typeof statements === "string" ? languageService.toAST(statements) : statements;
		return importDeclarationGetter.getForStatements(actualStatements, deep);
	}

	/**
	 * Tracks all BinaryExpressions in the given file, checks if they assign new values to identifiers and returns an array of IMutationDeclarations.
	 * @param {string} fileName
	 * @param {boolean} [deep=false]
	 * @returns {IMutationDeclaration[]}
	 */
	public getMutationsForFile (fileName: string, deep: boolean = false): IMutationDeclaration[] {
		return mutationGetter.getForFile(fileName, deep);
	}

	/**
	 * Tracks all BinaryExpressions in the given array of statements, checks if they assign new values to identifiers and returns an array of IMutationDeclarations.
	 * @param {string|(Statement|Expression|Node)[]} statements
	 * @param {boolean} [deep=false]
	 * @returns {IExportDeclaration[]}
	 */
	public getMutations (statements: string|(Statement|Expression|Node)[], deep: boolean = false): IMutationDeclaration[] {
		const actualStatements = typeof statements === "string" ? languageService.toAST(statements) : statements;
		return mutationGetter.getForStatements(actualStatements, deep);
	}

	/**
	 * Gets the member name for call expression.
	 * @param {CallExpression} statement
	 * @returns {string}
	 */
	private getCallExpressionMemberName (statement: CallExpression): string {
		if (isIdentifierObject(statement.expression)) return statement.expression.text;
		throw new TypeError(`${this.getCallExpressionMemberName.name} could not get the name for an expression!`);
	}
}