import {IMarshaller} from "@wessberg/marshaller";
import {dirname, join} from "path";
import * as ts from "typescript";
import {
	ArrayBindingPattern,
	ArrayLiteralExpression,
	ArrayTypeNode,
	ArrowFunction,
	BinaryExpression,
	BindingName,
	BindingPattern,
	Block,
	BooleanLiteral,
	CallExpression,
	ClassDeclaration,
	CompilerOptions,
	ComputedPropertyName,
	ConditionalExpression,
	ConstructorDeclaration,
	Declaration,
	DeclarationName,
	ElementAccessExpression,
	EntityName,
	EnumDeclaration,
	ExportDeclaration,
	Expression,
	ExpressionStatement,
	FunctionExpression,
	HeritageClause,
	Identifier,
	ImportDeclaration,
	IntersectionTypeNode,
	IScriptSnapshot,
	KeywordTypeNode,
	LanguageService,
	LeftHandSideExpression,
	MethodDeclaration,
	ModuleKind,
	NamedImports,
	NewExpression,
	Node,
	NodeArray,
	NoSubstitutionTemplateLiteral,
	NumericLiteral,
	ObjectBindingPattern,
	ObjectLiteralExpression,
	ParameterDeclaration,
	ParenthesizedExpression,
	PrefixUnaryExpression,
	PropertyAccessExpression,
	PropertyAssignment,
	PropertyDeclaration,
	PropertyName,
	ReturnStatement,
	ScriptTarget,
	SpreadAssignment,
	SpreadElement,
	Statement,
	StringLiteral,
	TemplateExpression,
	TemplateHead,
	TemplateSpan,
	TemplateTail,
	ThisExpression,
	Token,
	TupleTypeNode,
	TypeAliasDeclaration,
	TypeAssertion,
	TypeNode,
	TypeReferenceNode,
	UnionTypeNode,
	VariableStatement
} from "typescript";
import {BindingIdentifier} from "./BindingIdentifier";
import {
	ArbitraryValue,
	AssignmentMap,
	ICallExpressionArgument,
	IClassDeclaration,
	IModuleDependency,
	InitializationValue,
	IPropertyCallExpression,
	ISimpleLanguageService,
	NullableInitializationValue,
	PropIndexer,
	SyntaxKind,
	TypeArgument
} from "./interface/ISimpleLanguageService";

import {ISimpleLanguageServiceConfig} from "./interface/ISimpleLanguageServiceConfig";

/**
 * A service that parses and reflects on the AST generated by Typescript's language service.
 * With it, we can extract metadata such as initialization values and types, arguments and import
 * declarations.
 * @author Frederik Wessberg
 */
export class SimpleLanguageService implements ISimpleLanguageService {
	private languageService: LanguageService;
	private files: Map<string, { version: number, content: string }> = new Map();

	constructor (private marshaller: IMarshaller,
							 private config: ISimpleLanguageServiceConfig = {},
							 private typescript: typeof ts = ts) {
		this.languageService = this.typescript.createLanguageService(this, typescript.createDocumentRegistry());
	}

	/**
	 * Adds a new file to the LanguageService.
	 * @param {string} fileName
	 * @param {string} content
	 * @param {number} [version=0]
	 * @returns {void}
	 */
	public addFile (fileName: string, content: string, version: number = 0): NodeArray<Statement> {
		this.files.set(fileName, {version, content});
		return this.languageService.getProgram().getSourceFile(fileName).statements;
	}

	/**
	 * Gets the settings that Typescript will generate an AST from. There isn't much reason to make
	 * anything but the libs developer-facing since we only support ES2015 modules.
	 * @returns {CompilerOptions}
	 */
	public getCompilationSettings (): CompilerOptions {
		return {
			target: ScriptTarget.ES2017,
			module: ModuleKind.ES2015,
			lib: this.config.lib != null && this.config.lib.length > 0
				? this.config.lib
				: ["es2015.promise", "dom", "es6", "scripthost", "es7", "es2017.object", "es2015.proxy"]
		};
	}

	/**
	 * Gets the names of each file that has been added to the "program".
	 * @returns {string[]}
	 */
	public getScriptFileNames (): string[] {
		return [...this.files.keys()];
	}

	/**
	 * Gets the last version of the given fileName. Each time a file changes, the version number will be updated,
	 * so this can be useful to figure out if the file has changed since the program was run initially.
	 * @param {string} fileName
	 * @returns {string}
	 */
	public getScriptVersion (fileName: string): string {
		const script = this.files.get(fileName);
		if (script == null) return "-1";
		return script.version.toString();
	}

	/**
	 * Gets the last registered IScriptSnapshot, if any, otherwise undefined.
	 * @param {string} fileName
	 * @returns {IScriptSnapshot?}
	 */
	public getScriptSnapshot (fileName: string): IScriptSnapshot | undefined {
		const file = this.files.get(fileName);
		if (file == null) return undefined;
		return this.typescript.ScriptSnapshot.fromString(file.content);
	}

	/**
	 * Gets the current directory.
	 * @returns {string}
	 */
	public getCurrentDirectory (): string {
		return process.cwd();
	}

	/**
	 * Gets the default filepath for Typescript's lib-files.
	 * @param {CompilerOptions} options
	 * @returns {string}
	 */
	public getDefaultLibFileName (options: CompilerOptions): string {
		return this.typescript.getDefaultLibFilePath(options);
	}

	/**
	 * A predicate function that returns true if the given Statement is an ObjectLiteralExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isObjectLiteralExpression (statement: Statement | Declaration | Expression | Node): statement is ObjectLiteralExpression {
		return statement.kind === SyntaxKind.ObjectLiteralExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a VariableStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isVariableDeclaration (statement: Statement | Declaration | Expression | Node): statement is VariableStatement {
		return statement.kind === SyntaxKind.VariableStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a PropertyAccessExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPropertyAccessExpression (statement: Statement | Declaration | Expression | Node): statement is PropertyAccessExpression {
		return statement.kind === SyntaxKind.PropertyAccessExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a PropertyDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPropertyDeclaration (statement: Statement | Declaration | Expression | Node): statement is PropertyDeclaration {
		return statement.kind === SyntaxKind.PropertyDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ElementAccessExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isElementAccessExpression (statement: Statement | Declaration | Expression | Node): statement is ElementAccessExpression {
		return statement.kind === SyntaxKind.ElementAccessExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ArrayLiteralExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isArrayLiteralExpression (statement: Statement | Declaration | Expression | Node): statement is ArrayLiteralExpression {
		return statement.kind === SyntaxKind.ArrayLiteralExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeAssertion.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTypeAssertionExpression (statement: Statement | Declaration | Expression | Node): statement is TypeAssertion {
		return statement.kind === SyntaxKind.TypeAssertionExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an NoSubstitutionTemplateLiteral.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNoSubstitutionTemplateLiteral (statement: Statement | Declaration | Expression | Node): statement is NoSubstitutionTemplateLiteral {
		return statement.kind === SyntaxKind.NoSubstitutionTemplateLiteral;
	}

	/**
	 * A predicate function that returns true if the given Statement is a a TemplateExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTemplateExpression (statement: Statement | Declaration | Expression | Node): statement is TemplateExpression {
		return statement.kind === SyntaxKind.TemplateExpression || statement.kind === SyntaxKind.TaggedTemplateExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a an ArrowFunction.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isArrowFunction (statement: Statement | Declaration | Expression | Node): statement is ArrowFunction {
		return statement.kind === SyntaxKind.ArrowFunction;
	}

	/**
	 * A predicate function that returns true if the given Statement is a a FunctionExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isFunctionExpression (statement: Statement | Declaration | Expression | Node): statement is FunctionExpression {
		return statement.kind === SyntaxKind.FunctionExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an TemplateSpan.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTemplateSpan (statement: Statement | Declaration | Expression | Node): statement is TemplateSpan {
		return statement.kind === SyntaxKind.TemplateSpan;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ConditionalExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isConditionalExpression (statement: Statement | Declaration | Expression | Node): statement is ConditionalExpression {
		return statement.kind === SyntaxKind.ConditionalExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an CallExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isCallExpression (statement: Statement | Declaration | Expression | Node): statement is CallExpression {
		return statement.kind === SyntaxKind.CallExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a PrefixUnaryExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPrefixUnaryExpression (statement: Statement | Declaration | Expression | Node): statement is PrefixUnaryExpression {
		return statement.kind === SyntaxKind.PrefixUnaryExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ParenthesizedExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isParenthesizedExpression (statement: Statement | Declaration | Expression | Node): statement is ParenthesizedExpression {
		return statement.kind === SyntaxKind.ParenthesizedExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ParameterDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isParameterDeclaration (statement: Statement | Declaration | Expression | Node): statement is ParameterDeclaration {
		return statement.kind === SyntaxKind.Parameter;
	}

	/**
	 * A predicate function that returns true if the given Statement is a BinaryExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isBinaryExpression (statement: Statement | Declaration | Expression | Node): statement is BinaryExpression {
		return statement.kind === SyntaxKind.BinaryExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ImportDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isImportDeclaration (statement: Statement | Declaration | Expression | Node): statement is ImportDeclaration {
		return statement.kind === SyntaxKind.ImportDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is am EnumDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isEnumDeclaration (statement: Statement | Declaration | Expression | Node): statement is EnumDeclaration {
		return statement.kind === SyntaxKind.EnumDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'true'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTrueKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is BooleanLiteral {
		return statement.kind === SyntaxKind.TrueKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'false'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isFalseKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is BooleanLiteral {
		return statement.kind === SyntaxKind.FalseKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'undefined'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isUndefinedKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.UndefinedKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'null'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNullKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.NullKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'string'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isStringKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.StringKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'symbol'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isSymbolKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.SymbolKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'void'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isVoidKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.VoidKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'any'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isAnyKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.AnyKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'boolean'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isBooleanKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.BooleanKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'never'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNeverKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.NeverKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'number'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNumberKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.NumberKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is a NumericLiteral.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNumericLiteral (statement: TypeNode | Statement | Declaration | Expression | Node): statement is NumericLiteral {
		return statement.kind === SyntaxKind.NumericLiteral;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ObjectBindingPattern.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isObjectBindingPattern (statement: TypeNode | Statement | Declaration | Expression | Node): statement is ObjectBindingPattern {
		return statement.kind === SyntaxKind.ObjectBindingPattern;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ArrayBindingPattern.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isArrayBindingPattern (statement: TypeNode | Statement | Declaration | Expression | Node): statement is ArrayBindingPattern {
		return statement.kind === SyntaxKind.ArrayBindingPattern;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ArrayBindingPattern.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isBindingPattern (statement: TypeNode | Statement | Declaration | Expression | Node): statement is BindingPattern {
		return this.isObjectBindingPattern(statement) || this.isArrayBindingPattern(statement);
	}

	/**
	 * A predicate function that returns true if the given Statement is a PropertyName.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPropertyName (statement: Expression | Node): statement is PropertyName {
		return this.isIdentifierObject(statement) ||
			this.isStringLiteral(statement) ||
			this.isNumericLiteral(statement) ||
			this.isComputedPropertyName(statement);
	}

	/**
	 * A predicate function that returns true if the given Statement is a DeclarationName.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isDeclarationName (statement: Expression | Node): statement is DeclarationName {
		return this.isPropertyName(statement) || this.isBindingPattern(statement);
	}

	/**
	 * A predicate function that returns true if the given Statement is a TemplateHead.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTemplateHead (statement: TypeNode | Statement | Declaration | Expression | Node): statement is TemplateHead {
		return statement.kind === SyntaxKind.TemplateHead;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TemplateTail.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTemplateTail (statement: TypeNode | Statement | Declaration | Expression | Node): statement is TemplateTail {
		return statement.kind === SyntaxKind.TemplateTail;
	}

	/**
	 * A predicate function that returns true if the given Statement is a StringLiteral.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isStringLiteral (statement: TypeNode | Statement | Declaration | Expression | Node): statement is StringLiteral {
		return statement.kind === SyntaxKind.StringLiteral;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'object'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isObjectKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.ObjectKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'this'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isThisKeyword (statement: Statement | Declaration | Expression | Node): statement is ThisExpression {
		return statement.kind === SyntaxKind.ThisKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeNode
	 * @param {ParameterDeclaration|TypeAliasDeclaration|TypeNode} statement
	 * @returns {boolean}
	 */
	public isTypeNode (statement: ParameterDeclaration | TypeAliasDeclaration | TypeNode): statement is TypeNode {
		return this.isThisKeyword(statement) ||
			this.isArrayTypeNode(statement) ||
			this.isTupleTypeNode(statement) ||
			this.isIntersectionTypeNode(statement) ||
			this.isUnionTypeNode(statement) ||
			this.isObjectKeyword(statement) ||
			this.isNumberKeyword(statement) ||
			this.isNeverKeyword(statement) ||
			this.isBooleanKeyword(statement) ||
			this.isAnyKeyword(statement) ||
			this.isVoidKeyword(statement) ||
			this.isSymbolKeyword(statement) ||
			this.isStringKeyword(statement) ||
			this.isNullKeyword(statement) ||
			this.isUndefinedKeyword(statement) ||
			this.isTrueKeyword(statement) ||
			this.isFalseKeyword(statement);
	}

	/**
	 * A predicate function that returns true if the given Statement is a PropertyAssignment.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPropertyAssignment (statement: Statement | Declaration | Expression | Node): statement is PropertyAssignment {
		return statement.kind === SyntaxKind.PropertyAssignment;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ExpressionStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isExpressionStatement (statement: Statement | Declaration | Expression | Node): statement is ExpressionStatement {
		return statement.kind === SyntaxKind.ExpressionStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a SpreadAssignment.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isSpreadAssignment (statement: Statement | Declaration | Expression | Node): statement is SpreadAssignment {
		return statement.kind === SyntaxKind.SpreadAssignment;
	}

	/**
	 * A predicate function that returns true if the given Statement is a SpreadElement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isSpreadElement (statement: Statement | Declaration | Expression | Node): statement is SpreadElement {
		return statement.kind === SyntaxKind.SpreadElement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeReferenceNode.
	 * @param {ParameterDeclaration|TypeReferenceNode|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isTypeReference (statement: ParameterDeclaration | TypeReferenceNode | TypeNode | TypeAliasDeclaration): statement is TypeReferenceNode {
		return statement.kind === SyntaxKind.TypeReference;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ClassDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isClassDeclaration (statement: Statement | Declaration | Expression | Node): statement is ClassDeclaration {
		return statement.kind === SyntaxKind.ClassDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ConstructorDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isConstructorDeclaration (statement: Statement | Declaration | Expression | Node): statement is ConstructorDeclaration {
		return statement.kind === SyntaxKind.Constructor;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeReferenceNode.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTypeReferenceNode (statement: Statement | Declaration | Expression | Node): statement is TypeReferenceNode {
		return statement.kind === SyntaxKind.TypeReference;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ArrayTypeNode.
	 * @param {ParameterDeclaration|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isArrayTypeNode (statement: ParameterDeclaration | TypeNode | TypeAliasDeclaration): statement is ArrayTypeNode {
		return statement.kind === SyntaxKind.ArrayType;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TupleTypeNode.
	 * @param {ParameterDeclaration|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isTupleTypeNode (statement: ParameterDeclaration | TypeNode | TypeAliasDeclaration): statement is TupleTypeNode {
		return statement.kind === SyntaxKind.TupleType;
	}

	/**
	 * A predicate function that returns true if the given Statement is a UnionTypeNode.
	 * @param {ParameterDeclaration|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isUnionTypeNode (statement: ParameterDeclaration | TypeNode | TypeAliasDeclaration): statement is UnionTypeNode {
		return statement.kind === SyntaxKind.UnionType;
	}

	/**
	 * A predicate function that returns true if the given Statement is a IntersectionTypeNode.
	 * @param {ParameterDeclaration|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isIntersectionTypeNode (statement: ParameterDeclaration | TypeNode | TypeAliasDeclaration): statement is IntersectionTypeNode {
		return statement.kind === SyntaxKind.IntersectionType;
	}

	/**
	 * A predicate function that returns true if the given Statement is a MethodDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isMethodDeclaration (statement: Statement | Declaration | Expression | Node): statement is MethodDeclaration {
		return statement.kind === SyntaxKind.MethodDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is a NewExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNewExpression (statement: Statement | Declaration | Expression | Node): statement is NewExpression {
		return statement.kind === SyntaxKind.NewExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a Block.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isBlockDeclaration (statement: Statement | Declaration | Expression | Node): statement is Block {
		return statement.kind === SyntaxKind.Block;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ReturnStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isReturnStatement (statement: Statement | Declaration | Expression | Node): statement is ReturnStatement {
		return statement.kind === SyntaxKind.ReturnStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ExportDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isExportDeclaration (statement: Statement | Declaration | Expression | Node): statement is ExportDeclaration {
		return statement.kind === SyntaxKind.ExportDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is an Identifier.
	 * @param {BindingName|EntityName|Expression} statement
	 * @returns {boolean}
	 */
	public isIdentifierObject (statement: BindingName | EntityName | Expression | Node): statement is Identifier {
		return statement != null && statement.constructor.name === "IdentifierObject";
	}

	/**
	 * A predicate function that returns true if the given Statement is a TokenObject.
	 * @param {BindingName|EntityName|Expression} statement
	 * @returns {boolean}
	 */
	public isTokenObject (statement: BindingName | EntityName | Expression | Node): statement is Token<SyntaxKind> {
		return statement != null && statement.constructor.name === "TokenObject";
	}

	/**
	 * A predicate function that returns true if the given Statement is a FirstLiteralToken.
	 * @param {BindingName|EntityName|Expression} statement
	 * @returns {boolean}
	 */
	public isFirstLiteralToken (statement: BindingName | EntityName | Expression | Node): statement is Token<SyntaxKind.FirstLiteralToken> & { text: string } {
		return statement.kind === SyntaxKind.FirstLiteralToken;
	}


	/**
	 * A predicate function that returns true if the given Statement is a ComputedPropertyName.
	 * @param {BindingName|EntityName|Expression} statement
	 * @returns {boolean}
	 */
	public isComputedPropertyName (statement: BindingName | EntityName | Expression | Node): statement is ComputedPropertyName {
		return statement.kind === SyntaxKind.ComputedPropertyName;
	}

	/**
	 * A predicate function that returns true if the given Statement is a HeritageClause.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isExtendsKeyword (statement: Statement | Declaration | Expression | Node): statement is HeritageClause {
		// Extends will always be a 'token', not a 'kind'.
		return (<HeritageClause>statement).token === SyntaxKind.ExtendsKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is a NamedImports expression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNamedImports (statement: Statement | Declaration | Expression | Node): statement is NamedImports {
		// Extends will always be a 'token', not a 'kind'.
		return statement.kind === SyntaxKind.NamedImports;
	}

	/**
	 * Gets the decorators associated with the current expression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {string|null}
	 */
	public getDecorators (statement: Statement | Declaration | Expression | Node): string[] {
		if (statement.decorators == null) return [];
		// TODO: Remove any declaration!
		return statement.decorators.map((decorator: any) => decorator.expression.text);
	}

	/**
	 * Checks the token and returns the appropriate native version if possible, otherwise it returns the serialized version.
	 * @param {SyntaxKind} token
	 * @returns {ArbitraryValue}
	 */
	public marshalToken (token: SyntaxKind): ArbitraryValue {
		switch (token) {
			case SyntaxKind.NullKeyword:
				return null;
			case SyntaxKind.UndefinedKeyword:
				return undefined;
			case SyntaxKind.TrueKeyword:
				return true;
			case SyntaxKind.FalseKeyword:
				return false;
			default:
				return this.serializeToken(token);
		}
	}

	/**
	 * Serializes the given token (operand) and returns the textual representation of it.
	 * @param {SyntaxKind} token
	 * @returns {string}
	 */
	public serializeToken (token: SyntaxKind | TypeNode): string {
		switch (token) {
			case SyntaxKind.ObjectKeyword:
				return "object";
			case SyntaxKind.NumberKeyword:
				return "number";
			case SyntaxKind.NeverKeyword:
				return "never";
			case SyntaxKind.BooleanKeyword:
				return "boolean";
			case SyntaxKind.AnyKeyword:
				return "any";
			case SyntaxKind.VoidKeyword:
				return "void";
			case SyntaxKind.SymbolKeyword:
				return "symbol";
			case SyntaxKind.NullKeyword:
				return "null";
			case SyntaxKind.UndefinedKeyword:
				return "undefined";
			case SyntaxKind.StringKeyword:
				return "string";
			case SyntaxKind.TrueKeyword:
				return "true";
			case SyntaxKind.FalseKeyword:
				return "false";
			case SyntaxKind.BreakKeyword:
				return "break";
			case SyntaxKind.CatchKeyword:
				return "catch";
			case SyntaxKind.CaseKeyword:
				return "case";
			case SyntaxKind.ClassKeyword:
				return "class";
			case SyntaxKind.ConstKeyword:
				return "const";
			case SyntaxKind.ContinueKeyword:
				return "continue";
			case SyntaxKind.DebuggerKeyword:
				return "debugger";
			case SyntaxKind.DefaultKeyword:
				return "default";
			case SyntaxKind.DeleteKeyword:
				return "delete";
			case SyntaxKind.DoKeyword:
				return "do";
			case SyntaxKind.ElseKeyword:
				return "else";
			case SyntaxKind.EnumKeyword:
				return "enum";
			case SyntaxKind.ExportKeyword:
				return "export";
			case SyntaxKind.ExtendsKeyword:
				return "extends";
			case SyntaxKind.FinallyKeyword:
				return "finally";
			case SyntaxKind.ForKeyword:
				return "for";
			case SyntaxKind.FunctionKeyword:
				return "function";
			case SyntaxKind.IfKeyword:
				return "if";
			case SyntaxKind.ImportKeyword:
				return "import";
			case SyntaxKind.InKeyword:
				return "in";
			case SyntaxKind.InstanceOfKeyword:
				return "instanceof";
			case SyntaxKind.NewKeyword:
				return "new";
			case SyntaxKind.ReturnKeyword:
			case SyntaxKind.ReturnStatement:
				return "return";
			case SyntaxKind.SuperKeyword:
				return "super";
			case SyntaxKind.ThisKeyword:
				return "this";
			case SyntaxKind.ThrowKeyword:
				return "throw";
			case SyntaxKind.TryKeyword:
				return "try";
			case SyntaxKind.TypeOfKeyword:
				return "typeof";
			case SyntaxKind.VarKeyword:
				return "var";
			case SyntaxKind.WithKeyword:
				return "with";
			case SyntaxKind.ImplementsKeyword:
				return "implements";
			case SyntaxKind.InterfaceKeyword:
				return "interface";
			case SyntaxKind.LetKeyword:
				return "let";
			case SyntaxKind.PackageKeyword:
				return "package";
			case SyntaxKind.PrivateKeyword:
				return "private";
			case SyntaxKind.ProtectedKeyword:
				return "protected";
			case SyntaxKind.PublicKeyword:
				return "public";
			case SyntaxKind.StaticKeyword:
				return "static";
			case SyntaxKind.YieldKeyword:
				return "yield";
			case SyntaxKind.AbstractKeyword:
				return "abstract";
			case SyntaxKind.AsKeyword:
				return "as";
			case SyntaxKind.AsyncKeyword:
				return "async";
			case SyntaxKind.AwaitKeyword:
				return "await";
			case SyntaxKind.ConstructorKeyword:
				return "constructor";
			case SyntaxKind.DeclareKeyword:
				return "declare";
			case SyntaxKind.GetKeyword:
				return "get";
			case SyntaxKind.IsKeyword:
				return "is";
			case SyntaxKind.KeyOfKeyword:
				return "keyof";
			case SyntaxKind.ModuleKeyword:
				return "module";
			case SyntaxKind.NamespaceKeyword:
				return "namespace";
			case SyntaxKind.ReadonlyKeyword:
				return "readonly";
			case SyntaxKind.RequireKeyword:
				return "require";
			case SyntaxKind.SetKeyword:
				return "set";
			case SyntaxKind.TypeKeyword:
				return "type";
			case SyntaxKind.FromKeyword:
				return "from";
			case SyntaxKind.GlobalKeyword:
				return "global";
			case SyntaxKind.OfKeyword:
				return "of";
			case SyntaxKind.MinusToken:
				return "-";
			case SyntaxKind.PlusToken:
				return "+";
			case SyntaxKind.PlusPlusToken:
				return "++";
			case SyntaxKind.MinusMinusToken:
				return "--";
			case SyntaxKind.PlusEqualsToken:
				return "+=";
			case SyntaxKind.MinusEqualsToken:
				return "-=";
			case SyntaxKind.AsteriskToken:
				return "*";
			case SyntaxKind.AtToken:
				return "@";
			case SyntaxKind.EqualsEqualsEqualsToken:
				return "===";
			case SyntaxKind.EqualsEqualsToken:
				return "==";
			case SyntaxKind.EqualsGreaterThanToken:
				return "=>";
			case SyntaxKind.EqualsToken:
				return "=";
			case SyntaxKind.AsteriskEqualsToken:
				return "*=";
			case SyntaxKind.AsteriskAsteriskEqualsToken:
				return "**=";
			case SyntaxKind.ExclamationEqualsEqualsToken:
				return "!==";
			case SyntaxKind.ExclamationEqualsToken:
				return "!=";
			case SyntaxKind.ExclamationToken:
				return "!";
			case SyntaxKind.BarBarToken:
				return "||";
			case SyntaxKind.BarToken:
				return "|";
			case SyntaxKind.BarEqualsToken:
				return "|=";
			case SyntaxKind.AmpersandAmpersandToken:
				return "&&";
			case SyntaxKind.AmpersandEqualsToken:
				return "&=";
			case SyntaxKind.AmpersandToken:
				return "&";
			case SyntaxKind.SlashEqualsToken:
				return "/=";
			case SyntaxKind.SlashToken:
				return "/";
			case SyntaxKind.LessThanSlashToken:
				return "</";
			case SyntaxKind.PercentToken:
				return "%";
			case SyntaxKind.PercentEqualsToken:
				return "%=";
			case SyntaxKind.ColonToken:
				return ":";
			case SyntaxKind.SemicolonToken:
				return ";";
			case SyntaxKind.LessThanEqualsToken:
				return "<=";
			case SyntaxKind.LessThanToken:
				return "<";
			case SyntaxKind.LessThanLessThanEqualsToken:
				return "<<=";
			case SyntaxKind.LessThanLessThanToken:
				return "<<";
			case SyntaxKind.GreaterThanEqualsToken:
				return ">=";
			case SyntaxKind.GreaterThanGreaterThanEqualsToken:
				return ">>=";
			case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
				return ">>>";
			case SyntaxKind.GreaterThanGreaterThanToken:
				return ">>";
			case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
				return ">>>=";
			case SyntaxKind.GreaterThanToken:
				return ">";
			case SyntaxKind.QuestionToken:
				return "?";
			case SyntaxKind.TildeToken:
				return "~";
			case SyntaxKind.CaretToken:
				return "^";
			case SyntaxKind.CaretEqualsToken:
				return "^=";
			case SyntaxKind.AsteriskAsteriskToken:
				return "**";
			case SyntaxKind.CommaToken:
				return ",";
			case SyntaxKind.OpenBraceToken:
				return "{";
			case SyntaxKind.CloseBraceToken:
				return "}";
			case SyntaxKind.OpenParenToken:
				return "(";
			case SyntaxKind.CloseParenToken:
				return ")";
			case SyntaxKind.OpenBracketToken:
				return "[";
			case SyntaxKind.CloseBracketToken:
				return "]";
			case SyntaxKind.DotToken:
				return ".";
			case SyntaxKind.DotDotDotToken:
				return "...";
			default:
				return "";
		}
	}

	/**
	 * Checks if the given string is quoted, and if so, with which char (either ', " or `).
	 * @param {string} str
	 * @returns {string|null}
	 */
	private isQuotedWith (str: string): string | null {
		const quoteRegex = /["'`]/;
		const firstChar = str[0].trim();
		const isQuoted = quoteRegex.test(firstChar) && str.trim().endsWith(firstChar);
		return isQuoted ? firstChar : null;
	}

	/**
	 * Takes the text associated with an expression and returns a textual representation of it
	 * that plays nice with injection inside code.
	 * @param {Expression} statement
	 * @returns {TypeArgument}
	 */
	// TODO: Remove any declaration!
	private getExpressionTextMarshalled (statement: Expression | any): TypeArgument {
		if (this.isFalseKeyword(statement)) return false;
		if (this.isTrueKeyword(statement)) return true;
		if (this.isNullKeyword(statement)) return null;
		if (this.isUndefinedKeyword(statement)) return undefined;

		if (statement.text === null || statement.text === "null") return null;
		if (statement.text === undefined || statement.text === "undefined") return undefined;

		// Marshal the string into a native type.
		const marshalled = this.marshaller.marshal<string, TypeArgument>(statement.text);
		const isString = typeof marshalled === "string";

		// Wrap the string in quotes if it is not an identifier. Escape them if it is already quoted with a "`".
		if (isString && !this.isIdentifierObject(statement)) {

			const quotedWith = this.isQuotedWith(statement.text);
			return quotedWith === "`" ? `\`\\${statement.text.slice(0, statement.text.length - 1)}\\\`\`` : `\`${statement.text}\``;
		}

		return marshalled;
	}

	/**
	 * Gets and formats all PropertyCallExpressions associated with the given statements.
	 * These hold information such as the arguments the members are invoked with, generic type
	 * arguments and such.
	 * @param {NodeArray<Statement>} statements
	 * @returns {IPropertyCallExpression[]}
	 */
	public getPropertyCallExpressions (statements: NodeArray<Statement>): IPropertyCallExpression[] {
		const expressions: IPropertyCallExpression[] = [];
		let args: ICallExpressionArgument[] = [];

		statements.forEach(statement => {
			// TODO: Delegate all (or most of) this logic to 'getInitializedValue'?
			if (this.isExpressionStatement(statement)) {
				const exp = statement.expression;

				if (this.isCallExpression(exp)) {
					const expExp = exp.expression;

					exp.arguments.forEach(arg => {
						const startsAt = arg.pos;
						const endsAt = arg.end;
						args.push({
							startsAt,
							endsAt,
							// TODO: Use 'getInitializedValue' or 'getNameOfMember' here?
							value: this.getExpressionTextMarshalled(arg)
						});
					});


					if (this.isPropertyAccessExpression(expExp)) {
						// TODO: Remove any declaration
						const property = (<any>expExp.expression).text;
						const method = expExp.name.text;
						const typeArguments: string[] = [];

						if (exp.typeArguments != null) {
							exp.typeArguments.forEach(arg => {
								if (this.isTypeReference(arg)) {
									const typeName = arg.typeName;
									if (this.isIdentifierObject(typeName)) {
										typeArguments.push(typeName.text);
									}
								}
							});
						}

						expressions.push({
							callBlockPosition: {startsAt: exp.arguments.pos, endsAt: exp.arguments.end},
							property,
							method,
							typeArguments,
							args
						});
					}
				}
			}
		});
		return expressions;
	}

	/**
	 * If given an ImportDeclaration, a formatted IModuleDependency will be returned holding the relative and full import-path
	 * as well as any bindings that will live in the local scope of the given file.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @param {string} filepath
	 * @returns {IModuleDependency}
	 */
	public getImportDeclaration (statement: Statement | Declaration | Expression | Node, filepath: string): IModuleDependency {
		if (!this.isImportDeclaration(statement)) throw new Error(`Could not get an import declaration for statement that isn't an ImportDeclaration!`);

		// TODO: Remove any declaration
		const relativePath = (<any>statement.moduleSpecifier).text;
		const fullPath = join(dirname(filepath), relativePath);
		const clause = statement.importClause;

		if (clause == null || clause.namedBindings == null) {
			// A path import, e.g: "import './foo.ts'".
			return {
				relativePath,
				fullPath,
				bindings: []
			};
		}

		return {
			relativePath,
			fullPath,
			bindings: this.isNamedImports(clause.namedBindings) ? clause.namedBindings.elements.map(binding => binding.name.text) : []
		};
	}

	/**
	 * Gets the member name for call expression.
	 * @param {CallExpression} statement
	 * @returns {string}
	 */
	private getCallExpressionMemberName (statement: CallExpression): string {
		if (this.isIdentifierObject(statement.expression)) return statement.expression.text;
		throw new TypeError(`${this.getCallExpressionMemberName.name} could not get the name for an expression!`);
	}

	/**
	 * Gets all class fields associated with a class.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {PropIndexer}
	 */
	private getClassProps (statement: Statement | Declaration | Expression | Node): PropIndexer {
		const obj: PropIndexer = {};
		if (!this.isClassDeclaration(statement)) return obj;

		statement.members.forEach(memberStatement => {
			if (memberStatement.name == null) return;
			const name = <string>this.getNameOfMember(memberStatement.name, false, true);

			obj[name] = obj[name] || {decorators: [], type: null};

			if (this.isPropertyDeclaration(memberStatement)) {
				if (memberStatement.type != null) {
					const type = this.normalizeTypeDeclaration(memberStatement.type);
					obj[name].type = type == null ? null : type;
				}
			}

			if (memberStatement.decorators == null) return;
			memberStatement.decorators.forEach(decorator => {
				if (this.isIdentifierObject(decorator.expression)) {
					obj[name].decorators.push(decorator.expression.text);
				} else if (this.isCallExpression(decorator.expression)) {
					obj[name].decorators.push(this.getCallExpressionMemberName(decorator.expression));
				}
			});
		});

		return obj;
	}

	/**
	 * Gets all variable assignments (if any) that occurs in the given array of statements
	 * and returns them in an AssignmentMap.
	 * @param {NodeArray<Statement>} statements
	 * @returns {AssignmentMap}
	 */
	public getVariableAssignments (statements: NodeArray<Statement>): AssignmentMap {
		const assignmentMap: AssignmentMap = {};
		for (const statement of statements) {
			if (this.isVariableDeclaration(statement)) {
				const declarations = statement.declarationList.declarations;
				declarations.forEach(declaration => {
					if (this.isIdentifierObject(declaration.name)) {
						const boundName = declaration.name.text;
						if (declaration.initializer != null) {
							const value = this.getInitializedValue(declaration.initializer);
							if (value != null) {
								assignmentMap[boundName] = value;
							}
						}
					}
				});
			}
		}
		return assignmentMap;
	}

	/**
	 * Gets all class declarations (if any) that occurs in the given array of statements
	 * and returns them as an array.
	 * @param {NodeArray<Statement>} statements
	 * @param {string} filepath
	 * @param {string} code
	 * @returns {IClassDeclaration[]}
	 */
	public getClassDeclarations (statements: NodeArray<Statement>, filepath: string, code: string): IClassDeclaration[] {
		const declarations: IClassDeclaration[] = [];
		for (const statement of statements) {
			const declaration = this.getClassDeclaration(statement, filepath, code);
			if (declaration != null) declarations.push(declaration);
		}
		return declarations;
	}

	/**
	 * Gets and returns all ImportDeclarations (if any) that occur in the given file and array of statements.
	 * @param {NodeArray<Statement>} statements
	 * @param {string} filepath
	 * @returns {IModuleDependency[]}
	 */
	public getImportDeclarations (statements: NodeArray<Statement>, filepath: string): IModuleDependency[] {
		const declarations: IModuleDependency[] = [];
		for (const statement of statements) {
			if (this.isImportDeclaration(statement)) {
				const declaration = this.getImportDeclaration(statement, filepath);
				declarations.push(declaration);
			}
		}
		return declarations;
	}

	/**
	 * Gets all ExportDeclarations (if any) that occur in the given array of statements and returns a Set
	 * of all the identifiers that are being exported.
	 * @param {NodeArray<Statement>} statements
	 * @returns {Set<string>}
	 */
	public getExportDeclarations (statements: NodeArray<Statement>): Set<string> {
		const declarations: Set<string> = new Set();
		for (const statement of statements) {
			if (this.isExportDeclaration(statement)) {
				if (statement.exportClause != null) {
					statement.exportClause.elements.forEach(element => declarations.add(element.name.text));
				}
			}
		}
		return declarations;
	}


	/**
	 * Checks and formats the initialization value of the given statement (if any) and returns it.
	 * Since such a statement can be a combination of multiple operations and identifiers, an array of statements will be
	 * returned.
	 * @param {Statement|Expression|Node} rawStatement
	 * @returns {NullableInitializationValue}
	 */
	public getInitializedValue (rawStatement: Statement | Expression | Node): InitializationValue {

		console.log(this.getInitializedValuesForEnum.toString().slice(0, 0));

		if (this.isNumericLiteral(rawStatement)) {
			const marshalled = this.marshaller.marshal<string, number>(rawStatement.text);
			return [marshalled];
		}

		if (this.isStringLiteral(rawStatement)) {
			const marshalled = this.marshaller.marshal<string, ArbitraryValue>(rawStatement.text);
			return [marshalled];
		}

		if (this.isNoSubstitutionTemplateLiteral(rawStatement)) {
			const marshalled = this.marshaller.marshal<string, string>(rawStatement.text);
			return [marshalled];
		}

		if (this.isTemplateHead(rawStatement) || this.isTemplateTail(rawStatement)) {
			const marshalled = this.marshaller.marshal<string, string>(rawStatement.text, "");
			return [marshalled];
		}

		if (this.isTemplateSpan(rawStatement)) {
			const head = this.getInitializedValue(rawStatement.expression);
			const tail = this.getInitializedValue(rawStatement.literal);
			return [...(head || []), ...(tail || [])];
		}

		if (this.isBinaryExpression(rawStatement)) {
			const arr: InitializationValue = [];

			const left = this.getInitializedValue(rawStatement.left);
			const operator = this.getInitializedValue(rawStatement.operatorToken);
			const right = this.getInitializedValue(rawStatement.right);

			left.forEach(item => arr.push(item));
			operator.forEach(item => arr.push(item));
			right.forEach(item => arr.push(item));
			return arr;
		}

		if (this.isConditionalExpression(rawStatement)) {
			const arr: InitializationValue = [];
			const condition = this.getInitializedValue(rawStatement.condition);
			const question = this.getInitializedValue(rawStatement.questionToken);
			const colon = this.getInitializedValue(rawStatement.colonToken);
			const whenTrue = this.getInitializedValue(rawStatement.whenTrue);
			const whenFalse = this.getInitializedValue(rawStatement.whenFalse);

			condition.forEach(item => arr.push(item));
			question.forEach(item => arr.push(item));
			whenTrue.forEach(item => arr.push(item));
			colon.forEach(item => arr.push(item));
			whenFalse.forEach(item => arr.push(item));
			return arr;
		}

		if (this.isCallExpression(rawStatement) || this.isNewExpression(rawStatement)) {
			const name = this.getNameOfMember(rawStatement.expression);
			const arr: InitializationValue = [];
			if (this.isNewExpression(rawStatement)) arr.push("new ");
			arr.push(name);
			arr.push("(");
			const args = rawStatement.arguments;
			if (args != null) args.forEach((arg, index) => {
				const value = this.getInitializedValue(arg);
				value.forEach(item => {
					arr.push(item);
					if (index !== args.length - 1) arr.push(",");
				});
			});
			arr.push(")");
			return arr;
		}

		if (this.isObjectLiteralExpression(rawStatement)) {
			const obj: InitializationValue = ["{"];
			rawStatement.properties.forEach((property, index) => {

				if (this.isSpreadAssignment(property)) {
					obj.push("...");
					const exp = this.getInitializedValue(property.expression);
					exp.forEach(item => obj.push(item));
				} else {
					if (property.name == null) return;

					let value = this.isPropertyAssignment(property) ? this.getInitializedValue(property.initializer) : null;
					if (property.name == null) return;

					// Check if the property name is computed (.eg. [key]: "foo").
					if (this.isComputedPropertyName(property.name)) obj.push("[");

					// Check if the property name is computed and a call expression (.eg. [getKey()]: "foo").
					if (this.isComputedPropertyName(property.name) && this.isCallExpression(property.name.expression)) {
						const callExpression = this.getInitializedValue(property.name.expression);
						callExpression.forEach(item => obj.push(item));
					}

					else {
						// Otherwise, just push the name of it.
						obj.push(this.getNameOfMember(property.name, true));
					}

					if (this.isComputedPropertyName(property.name)) obj.push("]");
					obj.push(":");
					if (value == null) obj.push(value);
					else value.forEach(item => obj.push(item));
				}
				if (index !== rawStatement.properties.length - 1) obj.push(",");
			});
			obj.push("}");
			return obj;
		}

		if (this.isArrayLiteralExpression(rawStatement)) {
			const arr: InitializationValue = ["["];
			rawStatement.elements.forEach((element, index) => {
				const value = this.getInitializedValue(element);
				value.forEach(part => arr.push(part));
				const lastPart = value[value.length - 1];
				if (index !== rawStatement.elements.length - 1 && lastPart !== "...") arr.push(",");
			});

			arr.push("]");
			return arr;
		}

		if (this.isTemplateExpression(rawStatement)) {

			let values: InitializationValue = [...this.getInitializedValue(rawStatement.head)];

			rawStatement.templateSpans.forEach(span => {
				const content = this.getInitializedValue(span);
				// Remove empty strings from the contents and add everything else to the value array.
				content.filter(item => !(typeof item === "string" && item.length < 1)).forEach(checkedItem => values.push(checkedItem));
			});


			return ["\`", ...values, "\`"];
		}

		if (this.isPropertyAccessExpression(rawStatement)) {
			return [this.getPropertyAccessExpressionName(rawStatement)];
		}

		if (this.isElementAccessExpression(rawStatement)) {
			const baseName = this.getNameOfMember(rawStatement.expression);
			const argExpression = rawStatement.argumentExpression == null ? [] : this.getInitializedValue(rawStatement.argumentExpression);
			return [new BindingIdentifier([this.stringifyIdentifier(<BindingIdentifier>baseName), "[", ...argExpression, "]"].join(""))];
		}

		if (this.isParameterDeclaration(rawStatement)) {
			const name = this.getNameOfMember(rawStatement.name);
			const initializer = rawStatement.initializer == null ? null : this.getInitializedValue(rawStatement.initializer);
			const arr: InitializationValue = [name];
			if (initializer != null) {
				arr.push("=");
				initializer.forEach(item => arr.push(item));
			}
			return arr;
		}

		if (this.isArrowFunction(rawStatement)) {
			const arr: InitializationValue = ["("];
			const equalsGreaterThanToken = this.getInitializedValue(rawStatement.equalsGreaterThanToken);
			const body = this.getInitializedValue(rawStatement.body);

			rawStatement.parameters.forEach((parameter, index) => {
				const value = this.getInitializedValue(parameter);
				value.forEach(item => arr.push(item));
				if (index !== rawStatement.parameters.length - 1) arr.push(",");
			});

			arr.push(")");
			equalsGreaterThanToken.forEach(item => arr.push(item));
			body.forEach(item => arr.push(item));
			return arr;
		}

		if (this.isFunctionExpression(rawStatement)) {
			const arr: InitializationValue = ["function"];
			const body = this.getInitializedValue(rawStatement.body);

			if (rawStatement.name != null) {
				arr.push(this.getNameOfMember(rawStatement.name));
			}

			arr.push("(");

			rawStatement.parameters.forEach((parameter, index) => {
				const value = this.getInitializedValue(parameter);
				value.forEach(item => arr.push(item));
				if (index !== rawStatement.parameters.length - 1) arr.push(",");
			});
			arr.push(")");
			arr.push("{");
			body.forEach(item => arr.push(item));
			arr.push("}");
			return arr;
		}

		if (this.isBlockDeclaration(rawStatement)) {
			const arr: InitializationValue = [];
			rawStatement.statements.forEach(statement => {
				const value = this.getInitializedValue(statement);
				value.forEach(item => arr.push(item));
			});
			return arr;
		}

		if (this.isSpreadElement(rawStatement)) {
			return ["...", ...this.getInitializedValue(rawStatement.expression)];
		}

		if (this.isParenthesizedExpression(rawStatement)) {
			return ["(", ...this.getInitializedValue(rawStatement.expression), ")"];
		}

		if (this.isReturnStatement(rawStatement)) {
			return [this.marshalToken(rawStatement.kind), ...(rawStatement.expression == null ? [] : this.getInitializedValue(rawStatement.expression))];
		}

		if (this.isTokenObject(rawStatement)) {
			return [this.marshalToken(rawStatement.kind)];
		}

		if (this.isIdentifierObject(rawStatement)) {
			return [this.getNameOfMember(rawStatement, true)];
		}

		throw new TypeError(`${this.getInitializedValue.toString()} could not extract a value for a statement! of kind ${(<Identifier>rawStatement).kind == null ? "unknown" : SyntaxKind[(<Identifier>rawStatement).kind]}`);
	}

	/**
	 * Returns the name of an identifier.
	 * @param {BindingIdentifier|string} identifier
	 * @returns {string}
	 */
	private stringifyIdentifier (identifier: BindingIdentifier | string): string {
		return identifier instanceof BindingIdentifier ? identifier.name : identifier;
	}

	/**
	 * Computes the mot probable native type of the given string.
	 * @param {string} text
	 * @returns {string}
	 */
	private mostProbableTypeOf (text: string): string {
		return typeof this.marshaller.marshal<string, ArbitraryValue>(text);
	}

	/**
	 * Detects the name/key of a member of something (for example, an ObjectLiteral). If the second argument is truthy,
	 * the name may also be a non-string entity.
	 * @param {DeclarationName} name
	 * @param {boolean} [allowNonStringNames=false]
	 * @param {boolean} [forceNoBindingIdentifier=false]
	 * @returns {ArbitraryValue}
	 */
	private getNameOfMember (name: DeclarationName | LeftHandSideExpression, allowNonStringNames: boolean = false, forceNoBindingIdentifier: boolean = false): ArbitraryValue {

		if (this.isComputedPropertyName(name)) {
			if (this.isPropertyName(name.expression)) {
				if (this.isComputedPropertyName(name.expression)) return this.getNameOfMember(name.expression);
				return this.getNameOfMember(name.expression);
			}

			if (this.isCallExpression(name.expression)) {
				return this.getNameOfMember(name.expression.expression);
			}

			throw new TypeError(`${this.getNameOfMember.name} could not compute the name of a ${SyntaxKind[name.kind]}: It wasn't a PropertyName or a CallExpression. Instead, it was a ${SyntaxKind[name.expression.kind]}`);
		}

		if (this.isIdentifierObject(name)) {
			const marshalled = this.marshaller.marshal<string, ArbitraryValue>(name.text, allowNonStringNames ? undefined : "");

			if (name.parent != null && (this.isPropertyAssignment(name.parent) || this.isParameterDeclaration(name.parent))) {
				// Then this is the key of a property-assignment. We already know it isn't computed, so it can't be an identifier to another variable.
				return marshalled;
			}

			// Otherwise, it most likely is a reference to a variable or other Identifier unless it is a global symbol like "Infinity" or "Nan".
			if (this.mostProbableTypeOf(name.text) === "string" && !forceNoBindingIdentifier) {
				return new BindingIdentifier(name.text);
			}
			return marshalled;
		}

		if (this.isFirstLiteralToken(name)) {
			return this.marshaller.marshal<string, ArbitraryValue>(name.text, allowNonStringNames ? undefined : "");
		}

		if (this.isStringLiteral(name)) {
			return name.text;
		}

		if (this.isPropertyAccessExpression(name)) {
			return this.getPropertyAccessExpressionName(name);
		}

		throw new TypeError(`${this.getNameOfMember.name} could not compute the name of a ${SyntaxKind[name.kind]}.`);
	}

	/**
	 * Returns a BindingIdentifier containing a full property access.
	 * @param {PropertyAccessExpression} name
	 * @returns {BindingIdentifier}
	 */
	private getPropertyAccessExpressionName (name: PropertyAccessExpression): BindingIdentifier {
		const baseProp = this.getInitializedValue(name.expression);
		const path = this.getInitializedValue(name.name);
		return new BindingIdentifier([...baseProp.map(this.stringifyIdentifier), ...path.map(this.stringifyIdentifier)].join("."));
	}

	/**
	 * Flattens and returns an initialization value.
	 * @param {InitializationValue} value
	 * @param {boolean} [stringifyIdentifiers=false]
	 * @returns {string|null}
	 */
	public join (value: InitializationValue, stringifyIdentifiers: boolean = false): string | null {
		let str = "";
		value.map(item => {
			const trimmed = typeof item === "string" ? item.trim() : stringifyIdentifiers && item instanceof BindingIdentifier ? item.name : item;
			const whitespaced = trimmed === "new" ? `${trimmed} ` : trimmed;
			str += `${whitespaced}`;
		});
		return str;
	}

	/**
	 * Formats and returns a string representation of a type.
	 * @param {ParameterDeclaration|TypeAliasDeclaration|TypeNode} statement
	 * @returns {string|undefined}
	 */
	private normalizeTypeDeclaration (statement: ParameterDeclaration | TypeAliasDeclaration | TypeNode): string | undefined {
		if (this.isTypeNode(statement)) {

			if (this.isTypeReferenceNode(statement)) {
				// We have an identifier here.
				return (<Identifier>statement.typeName).text;
			}

			if (this.isArrayTypeNode(statement)) {
				return `${this.normalizeTypeDeclaration(statement.elementType)}[]`;
			}

			if (this.isTupleTypeNode(statement)) {
				return `[${statement.elementTypes.map(type => this.normalizeTypeDeclaration(type)).join(", ")}]`;
			}

			if (this.isIntersectionTypeNode(statement)) {
				return statement.types.map(intersectionType => this.normalizeTypeDeclaration(intersectionType)).join(" & ");
			}

			if (this.isUnionTypeNode(statement)) {
				return statement.types.map(unionType => this.normalizeTypeDeclaration(unionType)).join("|");
			}

			return this.serializeToken(statement.kind);
		} else {

			if (this.isTypeReference(statement)) {
				const typeName = statement.typeName;
				if (this.isIdentifierObject(typeName)) return typeName.text;
				return undefined;
			}

			return statement.type == null ? undefined : this.normalizeTypeDeclaration(statement.type);
		}
	}

	/**
	 * Gets a class declaration, including its methods, positions, which class it derives from,
	 * props and constructor arguments.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @param {string} filepath
	 * @param {string} fileContents
	 * @returns {IClassDeclaration}
	 */
	public getClassDeclaration (statement: Statement | Declaration | Expression | Node, filepath: string, fileContents: string): IClassDeclaration | null {
		if (!this.isClassDeclaration(statement) || statement.name == null) return null;

		const className = statement.name.text;
		const classDeclarationStartsAt = statement.pos;
		const classDeclarationEndsAt = statement.end;
		const classBodyStartsAt = fileContents.indexOf("{", classDeclarationStartsAt) + 1;
		const classBodyEndsAt = fileContents.indexOf("}", classDeclarationEndsAt - 1);
		const fullClassContents = fileContents.slice(classDeclarationStartsAt, classDeclarationEndsAt);
		const bodyClassContents = fileContents.slice(classBodyStartsAt, classBodyEndsAt);

		const declaration: IClassDeclaration = {
			name: className,
			filepath,
			methods: {},
			derives: null,
			constructorArguments: [],
			fullStartsAt: classDeclarationStartsAt,
			fullEndsAt: classDeclarationEndsAt,
			bodyStartsAt: classBodyStartsAt,
			bodyEndsAt: classBodyEndsAt,
			fullContents: fullClassContents,
			bodyContents: bodyClassContents,
			props: this.getClassProps(statement)
		};

		statement.members.forEach(member => {
			if (this.isConstructorDeclaration(member)) {
				member.parameters.forEach(parameter => {
					const name = (<Identifier>parameter.name).text;
					let type: string | undefined;
					let initializer: string | null = null;

					type = this.normalizeTypeDeclaration(parameter);

					const initValue = parameter.initializer != null ? this.getInitializedValue(parameter.initializer) : null;
					if (initValue != null) initializer = this.join(initValue, true);

					const startsAt = parameter.pos;
					const endsAt = parameter.end;
					declaration.constructorArguments.push({name, type, initializer, startsAt, endsAt});
				});
			}

			if (!this.isMethodDeclaration(member)) return;

			// TODO: Typescript doesn't think that a 'text' prop exists here. Who's right?
			const methodName = (<Identifier>member.name).text;

			const methodDeclarationStartsAt = member.pos;
			const methodDeclarationEndsAt = member.end;
			const methodBody = member.body;
			let methodBodyStartsAt = methodBody == null ? -1 : methodBody.pos;
			let methodBodyEndsAt = methodBody == null ? -1 : methodBody.end;
			const fullMethodContents = fileContents.slice(methodDeclarationStartsAt, methodDeclarationEndsAt);
			let bodyMethodContents = methodBody == null ? null : fileContents.slice(methodBodyStartsAt, methodBodyEndsAt);

			let returnStatementStartsAt: number = -1;
			let returnStatementEndsAt: number = -1;
			let returnStatementContents: string | null = null;
			let returnStatementTemplateStringContentsStartsAt: number = -1;
			let returnStatementTemplateStringContentsEndsAt: number = -1;
			let returnStatementTemplateStringContents: string | null = null;

			if (methodBody != null && methodBody.statements != null) {
				methodBody.statements.forEach(methodBodyStatement => {
					if (this.isReturnStatement(methodBodyStatement)) {
						if (methodBodyStatement.expression != null) {
							returnStatementStartsAt = methodBodyStatement.expression.pos;
							returnStatementEndsAt = methodBodyStatement.expression.end;
							returnStatementContents = fileContents.slice(returnStatementStartsAt, returnStatementEndsAt);
							if (this.isTemplateExpression(methodBodyStatement.expression)) {
								returnStatementTemplateStringContentsStartsAt = fileContents.indexOf("`", methodBodyStatement.expression.head.pos) + 1;
								returnStatementTemplateStringContentsEndsAt = methodBodyStatement.expression.templateSpans[methodBodyStatement.expression.templateSpans.length - 1].end - 1;
								returnStatementTemplateStringContents = fileContents.slice(returnStatementTemplateStringContentsStartsAt, returnStatementTemplateStringContentsEndsAt);
							} else if (this.isNoSubstitutionTemplateLiteral(methodBodyStatement.expression)) {
								returnStatementTemplateStringContentsStartsAt = fileContents.indexOf("`", methodBodyStatement.expression.pos) + 1;
								returnStatementTemplateStringContentsEndsAt = methodBodyStatement.expression.end - 1;
								returnStatementTemplateStringContents = fileContents.slice(returnStatementTemplateStringContentsStartsAt, returnStatementTemplateStringContentsEndsAt);
							}
						}
					}
				});
			}

			if (bodyMethodContents != null && bodyMethodContents.trim().startsWith("{")) {
				methodBodyStartsAt = fileContents.indexOf("{", methodBodyStartsAt) + 1;
				methodBodyEndsAt = fileContents.indexOf("}", methodBodyEndsAt - 1);
				bodyMethodContents = fileContents.slice(methodBodyStartsAt, methodBodyEndsAt);
			}

			declaration.methods[methodName] = {
				fullStartsAt: methodDeclarationStartsAt,
				fullEndsAt: methodDeclarationEndsAt,
				bodyStartsAt: methodBodyStartsAt,
				bodyEndsAt: methodBodyEndsAt,
				fullContents: fullMethodContents,
				bodyContents: bodyMethodContents,
				returnStatementStartsAt,
				returnStatementEndsAt,
				returnStatementContents,
				returnStatementTemplateStringContentsStartsAt,
				returnStatementTemplateStringContentsEndsAt,
				returnStatementTemplateStringContents
			};
		});

		if (statement.heritageClauses == null || statement.heritageClauses.length === 0) return declaration;

		let superClassName: string | null = null;
		for (const clause of statement.heritageClauses) {
			if (this.isExtendsKeyword(clause)) {
				const [type] = clause.types;
				// TODO: Why the need for casting? According to TS, text doesn't exist on this one.
				superClassName = (<Identifier>type.expression).text;
				declaration.derives = superClassName;
			}
		}
		return declaration;
	}

	/**
	 * Finds a free enum ordinal value. Free meaning that no other member of the enumeration is initialized to that value.
	 * @param {Set<number>} taken
	 * @returns {number}
	 */
	private findFreeEnumIntegerValue (taken: Set<number>): number {
		const sorted = [...taken].sort();

		for (let i = 0; i < sorted.length; i++) {
			if (taken.has(i)) continue;
			return i;
		}
		return sorted.length;
	}

	/**
	 * Walks through an enumeration and checks the associated ordinal values.
	 * @param {EnumDeclaration} statement
	 * @returns NullableInitializationValue}
	 */
	private getInitializedValuesForEnum (statement: EnumDeclaration): NullableInitializationValue {
		const props: { [key: string]: NullableInitializationValue } = {};
		const taken: Set<number> = new Set();
		statement.members.forEach(member => {
			// TODO: Typescript doesn't think that a 'text' key exists here. Why?
			const value = (<Identifier>member.name).text;
			const initializer = member.initializer;
			// TODO: Remove any declaration.
			const integerValue = initializer == null ? this.findFreeEnumIntegerValue(taken) : parseInt((<any>initializer).text);

			taken.add(integerValue);

			if (value != null) props[value] = [integerValue];
		});
		return [props];
	}

}