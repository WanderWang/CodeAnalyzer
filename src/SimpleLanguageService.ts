import {from} from "array-flatten";
import {dirname, join} from "path";
import {BindingIdentifier} from "./BindingIdentifier";
import {
	AssignmentMap,
	ICallExpressionArgument,
	IClassDeclaration,
	IModuleDependency,
	InitializationValue,
	IPropertyCallExpression,
	ISimpleLanguageService,
	NullableInitializationValue,
	PropIndexer,
	SyntaxKind,
	TypeArgument
} from "./interface/ISimpleLanguageService";

import {ISimpleLanguageServiceConfig} from "./interface/ISimpleLanguageServiceConfig";
import {
	ArrayLiteralExpression, ArrayTypeNode,
	BinaryExpression,
	BindingName,
	PropertyDeclaration,
	Block,
	BooleanLiteral,
	CallExpression,
	ClassDeclaration,
	ConditionalExpression,
	ConstructorDeclaration,
	Declaration,
	ElementAccessExpression, EntityName,
	EnumDeclaration,
	ExportDeclaration,
	Expression,
	CompilerOptions,
	ScriptTarget,
	ExpressionStatement,
	HeritageClause,
	Identifier,
	ImportDeclaration, IntersectionTypeNode, KeywordTypeNode,
	ModuleKind,
	MethodDeclaration,
	NamedImports, NewExpression,
	Node,
	NodeArray,
	NoSubstitutionTemplateLiteral,
	ObjectLiteralExpression, ParameterDeclaration,
	ParenthesizedExpression,
	PrefixUnaryExpression,
	PropertyAccessExpression,
	PropertyAssignment,
	Statement,
	TemplateExpression,
	TemplateSpan,
	ThisExpression, TupleTypeNode, TypeAliasDeclaration,
	TypeAssertion,
	TypeNode,
	TypeReferenceNode, UnionTypeNode,
	VariableStatement,
	LanguageService,
	ReturnStatement,
	ModifiersArray,
	IScriptSnapshot,
} from "typescript";
import * as ts from "typescript";
import {IMarshaller} from "@wessberg/marshaller";

/**
 * A service that parses and reflects on the AST generated by Typescript's language service.
 * With it, we can extract metadata such as initialization values and types, arguments and import
 * declarations.
 * @author Frederik Wessberg
 */
export class SimpleLanguageService implements ISimpleLanguageService {
	private languageService: LanguageService;
	private files: Map<string, { version: number, content: string }> = new Map();

	constructor (private typescript: typeof ts,
							 private config: ISimpleLanguageServiceConfig,
							 private marshaller: IMarshaller) {
		this.languageService = this.typescript.createLanguageService(this, typescript.createDocumentRegistry());
	}

	/**
	 * Adds a new file to the LanguageService.
	 * @param {string} fileName
	 * @param {string} content
	 * @param {number} [version=0]
	 * @returns {void}
	 */
	public addFile (fileName: string, content: string, version: number = 0): NodeArray<Statement> {
		this.files.set(fileName, {version, content});
		return this.languageService.getProgram().getSourceFile(fileName).statements;
	}

	/**
	 * Gets the settings that Typescript will generate an AST from. There isn't much reason to make
	 * anything but the libs developer-facing since we only support ES2015 modules.
	 * @returns {CompilerOptions}
	 */
	public getCompilationSettings (): CompilerOptions {
		return {
			target: ScriptTarget.ES2017,
			module: ModuleKind.ES2015,
			lib: this.config.lib != null && this.config.lib.length > 0
				? this.config.lib
				: ["es2015.promise", "dom", "es6", "scripthost", "es7", "es2017.object", "es2015.proxy"]
		};
	}

	/**
	 * Gets the names of each file that has been added to the "program".
	 * @returns {string[]}
	 */
	public getScriptFileNames (): string[] {
		return [...this.files.keys()];
	}

	/**
	 * Gets the last version of the given fileName. Each time a file changes, the version number will be updated,
	 * so this can be useful to figure out if the file has changed since the program was run initially.
	 * @param {string} fileName
	 * @returns {string}
	 */
	public getScriptVersion (fileName: string): string {
		const script = this.files.get(fileName);
		if (script == null) return "-1";
		return script.version.toString();
	}

	/**
	 * Gets the last registered IScriptSnapshot, if any, otherwise undefined.
	 * @param {string} fileName
	 * @returns {IScriptSnapshot?}
	 */
	public getScriptSnapshot (fileName: string): IScriptSnapshot | undefined {
		const file = this.files.get(fileName);
		if (file == null) return undefined;
		return this.typescript.ScriptSnapshot.fromString(file.content);
	}

	/**
	 * Gets the current directory.
	 * @returns {string}
	 */
	public getCurrentDirectory (): string {
		return process.cwd();
	}

	/**
	 * Gets the default filepath for Typescript's lib-files.
	 * @param {CompilerOptions} options
	 * @returns {string}
	 */
	public getDefaultLibFileName (options: CompilerOptions): string {
		return this.typescript.getDefaultLibFilePath(options);
	}

	/**
	 * A predicate function that returns true if the given Statement is an ObjectLiteralExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isObjectLiteralDeclaration (statement: Statement | Declaration | Expression | Node): statement is ObjectLiteralExpression {
		return statement.kind === SyntaxKind.ObjectLiteralExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a VariableStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isVariableDeclaration (statement: Statement | Declaration | Expression | Node): statement is VariableStatement {
		return statement.kind === SyntaxKind.VariableStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a PropertyAccessExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPropertyAccessExpression (statement: Statement | Declaration | Expression | Node): statement is PropertyAccessExpression {
		return statement.kind === SyntaxKind.PropertyAccessExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a PropertyDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPropertyDeclaration (statement: Statement | Declaration | Expression | Node): statement is PropertyDeclaration {
		return statement.kind === SyntaxKind.PropertyDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ElementAccessExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isElementAccessExpression (statement: Statement | Declaration | Expression | Node): statement is ElementAccessExpression {
		return statement.kind === SyntaxKind.ElementAccessExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ArrayLiteralExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isArrayLiteralExpression (statement: Statement | Declaration | Expression | Node): statement is ArrayLiteralExpression {
		return statement.kind === SyntaxKind.ArrayLiteralExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeAssertion.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTypeAssertionExpression (statement: Statement | Declaration | Expression | Node): statement is TypeAssertion {
		return statement.kind === SyntaxKind.TypeAssertionExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an NoSubstitutionTemplateLiteral.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNoSubstitutionTemplateLiteral (statement: Statement | Declaration | Expression | Node): statement is NoSubstitutionTemplateLiteral {
		return statement.kind === SyntaxKind.NoSubstitutionTemplateLiteral;
	}

	/**
	 * A predicate function that returns true if the given Statement is a a TemplateExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTemplateExpression (statement: Statement | Declaration | Expression | Node): statement is TemplateExpression {
		return statement.kind === SyntaxKind.TemplateExpression || statement.kind === SyntaxKind.TaggedTemplateExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an TemplateSpan.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTemplateSpan (statement: Statement | Declaration | Expression | Node): statement is TemplateSpan {
		return statement.kind === SyntaxKind.TemplateSpan;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ConditionalExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isConditionalExpression (statement: Statement | Declaration | Expression | Node): statement is ConditionalExpression {
		return statement.kind === SyntaxKind.ConditionalExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an CallExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isCallExpression (statement: Statement | Declaration | Expression | Node): statement is CallExpression {
		return statement.kind === SyntaxKind.CallExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a PrefixUnaryExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPrefixUnaryExpression (statement: Statement | Declaration | Expression | Node): statement is PrefixUnaryExpression {
		return statement.kind === SyntaxKind.PrefixUnaryExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ParenthesizedExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isParenthesizedExpression (statement: Statement | Declaration | Expression | Node): statement is ParenthesizedExpression {
		return statement.kind === SyntaxKind.ParenthesizedExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ParameterDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isParameterDeclaration (statement: Statement | Declaration | Expression | Node): statement is ParameterDeclaration {
		return statement.kind === SyntaxKind.Parameter;
	}

	/**
	 * A predicate function that returns true if the given Statement is a BinaryExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isBinaryExpression (statement: Statement | Declaration | Expression | Node): statement is BinaryExpression {
		return statement.kind === SyntaxKind.BinaryExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ImportDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isImportDeclaration (statement: Statement | Declaration | Expression | Node): statement is ImportDeclaration {
		return statement.kind === SyntaxKind.ImportDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is am EnumDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isEnumDeclaration (statement: Statement | Declaration | Expression | Node): statement is EnumDeclaration {
		return statement.kind === SyntaxKind.EnumDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'true'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTrueKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is BooleanLiteral {
		return statement.kind === SyntaxKind.TrueKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'false'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isFalseKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is BooleanLiteral {
		return statement.kind === SyntaxKind.FalseKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'undefined'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isUndefinedKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.UndefinedKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'null'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNullKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.NullKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'string'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isStringKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.StringKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'symbol'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isSymbolKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.SymbolKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'void'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isVoidKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.VoidKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'any'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isAnyKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.AnyKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'boolean'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isBooleanKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.BooleanKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'never'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNeverKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.NeverKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'number'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNumberKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.NumberKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'object'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isObjectKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.ObjectKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'this'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isThisKeyword (statement: Statement | Declaration | Expression | Node): statement is ThisExpression {
		return statement.kind === SyntaxKind.ThisKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeNode
	 * @param {ParameterDeclaration|TypeAliasDeclaration|TypeNode} statement
	 * @returns {boolean}
	 */
	public isTypeNode (statement: ParameterDeclaration | TypeAliasDeclaration | TypeNode): statement is TypeNode {
		return this.isThisKeyword(statement) ||
			this.isArrayTypeNode(statement) ||
			this.isTupleTypeNode(statement) ||
			this.isIntersectionTypeNode(statement) ||
			this.isUnionTypeNode(statement) ||
			this.isObjectKeyword(statement) ||
			this.isNumberKeyword(statement) ||
			this.isNeverKeyword(statement) ||
			this.isBooleanKeyword(statement) ||
			this.isAnyKeyword(statement) ||
			this.isVoidKeyword(statement) ||
			this.isSymbolKeyword(statement) ||
			this.isStringKeyword(statement) ||
			this.isNullKeyword(statement) ||
			this.isUndefinedKeyword(statement) ||
			this.isTrueKeyword(statement) ||
			this.isFalseKeyword(statement);
	}

	/**
	 * A predicate function that returns true if the given Statement is a PropertyAssignment.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPropertyAssignment (statement: Statement | Declaration | Expression | Node): statement is PropertyAssignment {
		return statement.kind === SyntaxKind.PropertyAssignment;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ExpressionStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isExpressionStatement (statement: Statement | Declaration | Expression | Node): statement is ExpressionStatement {
		return statement.kind === SyntaxKind.ExpressionStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeReferenceNode.
	 * @param {ParameterDeclaration|TypeReferenceNode|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isTypeReference (statement: ParameterDeclaration | TypeReferenceNode | TypeNode | TypeAliasDeclaration): statement is TypeReferenceNode {
		return statement.kind === SyntaxKind.TypeReference;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ClassDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isClassDeclaration (statement: Statement | Declaration | Expression | Node): statement is ClassDeclaration {
		return statement.kind === SyntaxKind.ClassDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ConstructorDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isConstructorDeclaration (statement: Statement | Declaration | Expression | Node): statement is ConstructorDeclaration {
		return statement.kind === SyntaxKind.Constructor;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeReferenceNode.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTypeReferenceNode (statement: Statement | Declaration | Expression | Node): statement is TypeReferenceNode {
		return statement.kind === SyntaxKind.TypeReference;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ArrayTypeNode.
	 * @param {ParameterDeclaration|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isArrayTypeNode (statement: ParameterDeclaration | TypeNode | TypeAliasDeclaration): statement is ArrayTypeNode {
		return statement.kind === SyntaxKind.ArrayType;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TupleTypeNode.
	 * @param {ParameterDeclaration|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isTupleTypeNode (statement: ParameterDeclaration | TypeNode | TypeAliasDeclaration): statement is TupleTypeNode {
		return statement.kind === SyntaxKind.TupleType;
	}

	/**
	 * A predicate function that returns true if the given Statement is a UnionTypeNode.
	 * @param {ParameterDeclaration|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isUnionTypeNode (statement: ParameterDeclaration | TypeNode | TypeAliasDeclaration): statement is UnionTypeNode {
		return statement.kind === SyntaxKind.UnionType;
	}

	/**
	 * A predicate function that returns true if the given Statement is a IntersectionTypeNode.
	 * @param {ParameterDeclaration|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isIntersectionTypeNode (statement: ParameterDeclaration | TypeNode | TypeAliasDeclaration): statement is IntersectionTypeNode {
		return statement.kind === SyntaxKind.IntersectionType;
	}

	/**
	 * A predicate function that returns true if the given Statement is a MethodDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isMethodDeclaration (statement: Statement | Declaration | Expression | Node): statement is MethodDeclaration {
		return statement.kind === SyntaxKind.MethodDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is a NewExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNewExpression (statement: Statement | Declaration | Expression | Node): statement is NewExpression {
		return statement.kind === SyntaxKind.NewExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a Block.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isBlockDeclaration (statement: Statement | Declaration | Expression | Node): statement is Block {
		return statement.kind === SyntaxKind.Block;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ReturnStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isReturnStatement (statement: Statement | Declaration | Expression | Node): statement is ReturnStatement {
		return statement.kind === SyntaxKind.ReturnStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ExportDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isExportDeclaration (statement: Statement | Declaration | Expression | Node): statement is ExportDeclaration {
		return statement.kind === SyntaxKind.ExportDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is an Identifier.
	 * @param {BindingName|EntityName|Expression} statement
	 * @returns {boolean}
	 */
	public isIdentifierObject (statement: BindingName | EntityName | Expression): statement is Identifier {
		return statement != null && statement.constructor.name === "IdentifierObject";
	}

	/**
	 * A predicate function that returns true if the given Statement is a HeritageClause.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isExtendsKeyword (statement: Statement | Declaration | Expression | Node): statement is HeritageClause {
		// Extends will always be a 'token', not a 'kind'.
		return (<HeritageClause>statement).token === SyntaxKind.ExtendsKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is a NamedImports expression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNamedImports (statement: Statement | Declaration | Expression | Node): statement is NamedImports {
		// Extends will always be a 'token', not a 'kind'.
		return statement.kind === SyntaxKind.NamedImports;
	}

	/**
	 * Gets the name of the current scope. For example, a class member's scope will be the name of the class.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {string|null}
	 */
	public getScope (statement: Statement | Declaration | Expression | Node): string | null {
		return this.isClassDeclaration(statement) && statement.name != null ? statement.name.text : null;
	}

	/**
	 * Returns true if the current statement represents a static class member.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isStatic (statement: Statement | Declaration | Expression | Node): boolean {
		if (statement.modifiers == null) return false;
		if (this.isObjectLiteralDeclaration(statement) || this.isEnumDeclaration(statement)) return false;
		return (<ModifiersArray>statement.modifiers).some(modifier => modifier.kind === SyntaxKind.StaticKeyword);
	}

	/**
	 * Gets the name for the current member of a class or object.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @param {boolean} [traceParentPath=false]
	 * @returns {string|null}
	 */
	public getName (statement: Statement | Declaration | Expression | Node, traceParentPath: boolean = false): string | null {

		let path = traceParentPath ? `${this.extractParentPath(statement)}` : "";
		if ((<Declaration>statement).name != null && (<Identifier>(<Declaration>statement).name).text != null) {
			path += `${(<Identifier>(<Declaration>statement).name).text}`;
		}
		return path.length < 1 ? null : path;
	}

	/**
	 * Gets the decorators associated with the current expression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {string|null}
	 */
	public getDecorators (statement: Statement | Declaration | Expression | Node): string[] {
		if (statement.decorators == null) return [];
		// TODO: Remove any declaration!
		return statement.decorators.map((decorator: any) => decorator.expression.text);
	}

	/**
	 * Serializes the given type keyword and returns the textual representation of it.
	 * @param {TypeNode} keyword
	 * @returns {string?}
	 */
	public serializeTypeKeyword (keyword: TypeNode): string | undefined {
		switch (keyword.kind) {
			case SyntaxKind.ObjectKeyword:
				return "object";
			case SyntaxKind.NumberKeyword:
				return "number";
			case SyntaxKind.NeverKeyword:
				return "never";
			case SyntaxKind.BooleanKeyword:
				return "boolean";
			case SyntaxKind.AnyKeyword:
				return "any";
			case SyntaxKind.VoidKeyword:
				return "void";
			case SyntaxKind.SymbolKeyword:
				return "symbol";
			case SyntaxKind.NullKeyword:
				return "null";
			case SyntaxKind.UndefinedKeyword:
				return "undefined";
			case SyntaxKind.StringKeyword:
				return "string";
		}
		return undefined;
	}

	/**
	 * Serializes the given token (operand) and returns the textual representation of it.
	 * @param {SyntaxKind} token
	 * @returns {string}
	 */
	public serializeToken (token: SyntaxKind): string {
		switch (token) {
			case SyntaxKind.MinusToken:
				return "-";
			case SyntaxKind.PlusToken:
				return "+";
			case SyntaxKind.PlusPlusToken:
				return "++";
			case SyntaxKind.MinusMinusToken:
				return "--";
			case SyntaxKind.PlusEqualsToken:
				return "+=";
			case SyntaxKind.MinusEqualsToken:
				return "-=";
			case SyntaxKind.AsteriskToken:
				return "*";
			case SyntaxKind.AtToken:
				return "@";
			case SyntaxKind.EqualsEqualsEqualsToken:
				return "===";
			case SyntaxKind.EqualsEqualsToken:
				return "==";
			case SyntaxKind.EqualsGreaterThanToken:
				return "=>";
			case SyntaxKind.EqualsToken:
				return "=";
			case SyntaxKind.AsteriskEqualsToken:
				return "*=";
			case SyntaxKind.AsteriskAsteriskEqualsToken:
				return "**=";
			case SyntaxKind.ExclamationEqualsEqualsToken:
				return "!==";
			case SyntaxKind.ExclamationEqualsToken:
				return "!=";
			case SyntaxKind.ExclamationToken:
				return "!";
			case SyntaxKind.BarBarToken:
				return "||";
			case SyntaxKind.BarToken:
				return "|";
			case SyntaxKind.BarEqualsToken:
				return "|=";
			case SyntaxKind.AmpersandAmpersandToken:
				return "&&";
			case SyntaxKind.AmpersandEqualsToken:
				return "&=";
			case SyntaxKind.AmpersandToken:
				return "&";
			case SyntaxKind.SlashEqualsToken:
				return "/=";
			case SyntaxKind.SlashToken:
				return "/";
			case SyntaxKind.LessThanSlashToken:
				return "</";
			case SyntaxKind.PercentToken:
				return "%";
			case SyntaxKind.PercentEqualsToken:
				return "%=";
			case SyntaxKind.ColonToken:
				return ":";
			case SyntaxKind.SemicolonToken:
				return ";";
			case SyntaxKind.LessThanEqualsToken:
				return "<=";
			case SyntaxKind.LessThanToken:
				return "<";
			case SyntaxKind.LessThanLessThanEqualsToken:
				return "<<=";
			case SyntaxKind.LessThanLessThanToken:
				return "<<";
			case SyntaxKind.GreaterThanEqualsToken:
				return ">=";
			case SyntaxKind.GreaterThanGreaterThanEqualsToken:
				return ">>=";
			case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
				return ">>>";
			case SyntaxKind.GreaterThanGreaterThanToken:
				return ">>";
			case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
				return ">>>=";
			case SyntaxKind.GreaterThanToken:
				return ">";
			case SyntaxKind.QuestionToken:
				return "?";
			case SyntaxKind.TildeToken:
				return "~";
			case SyntaxKind.CaretToken:
				return "^";
			case SyntaxKind.CaretEqualsToken:
				return "^=";
			case SyntaxKind.AsteriskAsteriskToken:
				return "**";
			case SyntaxKind.CommaToken:
				return ",";
			case SyntaxKind.OpenBraceToken:
				return "{";
			case SyntaxKind.CloseBraceToken:
				return "}";
			case SyntaxKind.OpenParenToken:
				return "(";
			case SyntaxKind.CloseParenToken:
				return ")";
			case SyntaxKind.OpenBracketToken:
				return "[";
			case SyntaxKind.CloseBracketToken:
				return "]";
			case SyntaxKind.DotToken:
				return ".";
			case SyntaxKind.DotDotDotToken:
				return "...";
			default:
				return "";
		}
	}

	/**
	 * Checks if the given string is quoted, and if so, with which char (either ', " or `).
	 * @param {string} str
	 * @returns {string|null}
	 */
	private isQuotedWith (str: string): string | null {
		const quoteRegex = /["'`]/;
		const firstChar = str[0].trim();
		const isQuoted = quoteRegex.test(firstChar) && str.trim().endsWith(firstChar);
		return isQuoted ? firstChar : null;
	}

	/**
	 * Takes the text associated with an expression and returns a textual representation of it
	 * that plays nice with injection inside code.
	 * @param {Expression} statement
	 * @returns {TypeArgument}
	 */
	// TODO: Remove any declaration!
	private getExpressionTextMarshalled (statement: Expression|any): TypeArgument {
		if (this.isFalseKeyword(statement)) return false;
		if (this.isTrueKeyword(statement)) return true;
		if (this.isNullKeyword(statement)) return null;
		if (this.isUndefinedKeyword(statement)) return undefined;

		if (statement.text === null || statement.text === "null") return null;
		if (statement.text === undefined || statement.text === "undefined") return undefined;

		// Marshal the string into a native type.
		const marshalled = this.marshaller.marshal<string, TypeArgument>(statement.text);
		const isString = typeof marshalled === "string";

		// Wrap the string in quotes if it is not an identifier. Escape them if it is already quoted with a "`".
		if (isString && !this.isIdentifierObject(statement)) {

			const quotedWith = this.isQuotedWith(statement.text);
			return quotedWith === "`" ? `\`\\${statement.text.slice(0, statement.text.length - 1)}\\\`\`` : `\`${statement.text}\``;
		}

		return marshalled;
	}

	/**
	 * Gets and formats all PropertyCallExpressions associated with the given statements.
	 * These hold information such as the arguments the members are invoked with, generic type
	 * arguments and such.
	 * @param {NodeArray<Statement>} statements
	 * @returns {IPropertyCallExpression[]}
	 */
	public getPropertyCallExpressions (statements: NodeArray<Statement>): IPropertyCallExpression[] {
		const expressions: IPropertyCallExpression[] = [];
		let args: ICallExpressionArgument[] = [];

		statements.forEach(statement => {
			if (this.isExpressionStatement(statement)) {
				const exp = statement.expression;

				if (this.isCallExpression(exp)) {
					const expExp = exp.expression;

					exp.arguments.forEach(arg => {
						const startsAt = arg.pos;
						const endsAt = arg.end;
						args.push({
							startsAt,
							endsAt,
							value: this.getExpressionTextMarshalled(arg)
						});
					});


					if (this.isPropertyAccessExpression(expExp)) {
						// TODO: Remove any declaration
						const property = (<any>expExp.expression).text;
						const method = expExp.name.text;
						const typeArguments: string[] = [];

						if (exp.typeArguments != null) {
							exp.typeArguments.forEach(arg => {
								if (this.isTypeReference(arg)) {
									const typeName = arg.typeName;
									if (this.isIdentifierObject(typeName)) {
										typeArguments.push(typeName.text);
									}
								}
							});
						}

						expressions.push({
							callBlockPosition: {startsAt: exp.arguments.pos, endsAt: exp.arguments.end},
							property,
							method,
							typeArguments,
							args
						});
					}
				}
			}
		});
		return expressions;
	}

	/**
	 * If given an ImportDeclaration, a formatted IModuleDependency will be returned holding the relative and full import-path
	 * as well as any bindings that will live in the local scope of the given file.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @param {string} filepath
	 * @returns {IModuleDependency}
	 */
	public getImportDeclaration (statement: Statement | Declaration | Expression | Node, filepath: string): IModuleDependency {
		if (!this.isImportDeclaration(statement)) throw new Error(`Could not get an import declaration for statement that isn't an ImportDeclaration!`);

		// TODO: Remove any declaration
		const relativePath = (<any>statement.moduleSpecifier).text;
		const fullPath = join(dirname(filepath), relativePath);
		const clause = statement.importClause;

		if (clause == null || clause.namedBindings == null) {
			// A path import, e.g: "import './foo.ts'".
			return {
				relativePath,
				fullPath,
				bindings: []
			};
		}

		return {
			relativePath,
			fullPath,
			bindings: this.isNamedImports(clause.namedBindings) ? clause.namedBindings.elements.map(binding => binding.name.text) : []
		};
	}

	/**
	 * Gets all class fields associated with a class.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {PropIndexer}
	 */
	private getClassProps (statement: Statement | Declaration | Expression | Node): PropIndexer {
		const obj: PropIndexer = {};
		if (!this.isClassDeclaration(statement)) return obj;

		statement.members.forEach(memberStatement => {
			const name = this.getName(memberStatement, false);

			if (name == null) return;
			obj[name] = obj[name] || {decorators: [], type: null};

			if (this.isPropertyDeclaration(memberStatement)) {
				if (memberStatement.type != null) {
					const type = this.normalizeTypeDeclaration(memberStatement.type);
					obj[name].type = type == null ? null : type;
				}
			}

			if (memberStatement.decorators == null) return;
			memberStatement.decorators.forEach(decorator => {
				// TODO: Remove any declaration.
				const text = (<any>decorator.expression).text;
				obj[name].decorators.push(text);
			});
		});

		return obj;
	}

	/**
	 * Gets all variable assignments (if any) that occurs in the given array of statements
	 * and returns them in an AssignmentMap.
	 * @param {NodeArray<Statement>} statements
	 * @returns {AssignmentMap}
	 */
	public getVariableAssignments (statements: NodeArray<Statement>): AssignmentMap {
		const assignmentMap: AssignmentMap = {};
		for (const statement of statements) {
			if (this.isVariableDeclaration(statement)) {
				const declarations = statement.declarationList.declarations;
				declarations.forEach(declaration => {
					if (this.isIdentifierObject(declaration.name)) {
						const boundName = declaration.name.text;
						if (declaration.initializer != null) {
							const value = this.getInitializedValue(declaration.initializer, null);
							if (value != null) {
								const joined = this.join(value, true);
								if (joined != null) assignmentMap[boundName] = joined;
							}
						}
					}
				});
			}
		}
		return assignmentMap;
	}

	/**
	 * Gets all class declarations (if any) that occurs in the given array of statements
	 * and returns them as an array.
	 * @param {NodeArray<Statement>} statements
	 * @param {string} filepath
	 * @param {string} code
	 * @returns {IClassDeclaration[]}
	 */
	public getClassDeclarations (statements: NodeArray<Statement>, filepath: string, code: string): IClassDeclaration[] {
		const declarations: IClassDeclaration[] = [];
		for (const statement of statements) {
			const declaration = this.getClassDeclaration(statement, filepath, code);
			if (declaration != null) declarations.push(declaration);
		}
		return declarations;
	}

	/**
	 * Gets and returns all ImportDeclarations (if any) that occur in the given file and array of statements.
	 * @param {NodeArray<Statement>} statements
	 * @param {string} filepath
	 * @returns {IModuleDependency[]}
	 */
	public getImportDeclarations (statements: NodeArray<Statement>, filepath: string): IModuleDependency[] {
		const declarations: IModuleDependency[] = [];
		for (const statement of statements) {
			if (this.isImportDeclaration(statement)) {
				const declaration = this.getImportDeclaration(statement, filepath);
				declarations.push(declaration);
			}
		}
		return declarations;
	}

	/**
	 * Gets all ExportDeclarations (if any) that occur in the given array of statements and returns a Set
	 * of all the identifiers that are being exported.
	 * @param {NodeArray<Statement>} statements
	 * @returns {Set<string>}
	 */
	public getExportDeclarations (statements: NodeArray<Statement>): Set<string> {
		const declarations: Set<string> = new Set();
		for (const statement of statements) {
			if (this.isExportDeclaration(statement)) {
				if (statement.exportClause != null) {
					statement.exportClause.elements.forEach(element => declarations.add(element.name.text));
				}
			}
		}
		return declarations;
	}

	/**
	 * Checks and formats the initialization value of the given statement (if any) and returns it.
	 * Since such a statement can be a combination of multiple operations and identifiers, an array of statements will be
	 * returned.
	 * @param {Statement|Expression|Node} rawStatement
	 * @param {string|null} currentScope
	 * @returns {NullableInitializationValue}
	 */
	public getInitializedValue (rawStatement: Statement|Expression|Node, currentScope: string | null): NullableInitializationValue {
		// TODO: Remove any declarations
		const statement = (<any>rawStatement).initializer == null ? rawStatement : (<any>rawStatement).initializer;
		if (statement == null) return null;

		if (this.isTemplateSpan(rawStatement)) {
			const initializedValue = this.getInitializedValue(rawStatement.expression, currentScope);
			if (!this.initializedValueIsDefined(initializedValue) && (<TemplateSpan>statement).literal.text == null) return null;
			return this.flatten([initializedValue, (<TemplateSpan>statement).literal.text]);
		}

		if (this.isBinaryExpression(statement)) {
			// TODO: Fix the typing system!
			/* tslint:disable */
			const arr: any = [];
			/* tslint:enable */
			const left = this.getInitializedValue(statement.left, currentScope);
			const operator = this.serializeToken(statement.operatorToken.kind);
			const right = this.getInitializedValue(statement.right, currentScope);
			arr.push(left);
			arr.push(operator);
			arr.push(right);
			return this.flatten(arr);
		}

		if (this.isTypeAssertionExpression(statement)) {
			return this.getInitializedValue(statement.expression, currentScope);
		}

		if (this.isParenthesizedExpression(statement)) {
			const contents = this.getInitializedValue(statement.expression, currentScope);
			if (contents == null) return null;
			return this.flatten(["(", ...contents, ")"]);
		}

		if (this.isPrefixUnaryExpression(statement)) {
			const prefixOperator = this.serializeToken(statement.operator);
			// TODO: Remove any declarations.
			const value = (<any>statement.operand).text == null ? this.getInitializedValue(statement.operand, currentScope) : (<any>statement.operand).text;

			return this.flatten([prefixOperator, value]);
		}

		if (this.isCallExpression(statement) || this.isNewExpression(statement)) {
			const value = this.getInitializedValue(statement.expression, currentScope);
			if (!this.initializedValueIsDefined(value)) return null;

			// TODO: Fix InitializationValue.
			/* tslint:disable */
			const res: any[] = [value, "("];
			/* tslint:enable */
			const mappedArgs = statement.arguments == null ? [] : statement.arguments.map(argument => this.getInitializedValue(argument, currentScope));
			mappedArgs.forEach((arg, index) => {
				res.push(arg);
				if (index !== mappedArgs.length - 1) res.push(",");
			});
			res.push(")");
			return this.isNewExpression(statement) ? this.flatten(["new", ...res]) : this.flatten(res);
		}

		if (this.isConditionalExpression(statement)) {

			// TODO: FIX the typing system!
			/* tslint:disable */
			let arr: any = [];
			/* tslint:enable */
			const condition = this.getInitializedValue(statement.condition, currentScope);
			const whenTrue = this.getInitializedValue(statement.whenTrue, currentScope);
			const whenFalse = this.getInitializedValue(statement.whenFalse, currentScope);

			if (this.initializedValueIsDefined(condition)) {
				arr.push("(");
				arr.push(condition);
				arr.push(")");
				arr.push("?");
				arr.push(whenTrue);
				arr.push(":");
				arr.push(whenFalse);
			}

			return this.flatten(arr);
		}

		if (this.isEnumDeclaration(statement)) {
			return this.getInitializedValuesForEnum(statement);
		}

		if (this.isTemplateExpression(statement)) {

			const head = statement.head != null ? statement.head.text : null;
			let values: InitializationValue = [];
			if (head != null) values.push(head);

			statement.templateSpans.forEach(span => {
				// TODO: Remove any declaration.
				const content = this.getInitializedValue(span, currentScope);
				if (content != null) values = values.concat(content);
			});
			return this.initializedValueIsDefined(values) ? ["\`", ...values, "\`"] : null;
		}

		if (this.isArrayLiteralExpression(statement)) {
			// TODO: FIX The typing system!
			/* tslint:disable */
			const arr: any[] = ["["];
			/* tslint:enable */
			const mapped = statement.elements.map(element => {
				if (this.isObjectLiteralDeclaration(element)) return this.getInitializedValuesForObjectLiteral(element, currentScope);
				if (this.isPropertyAccessExpression(element) || this.isElementAccessExpression(element)) return this.getInitializedValuesForPropertyAccess(element, currentScope);
				if (this.isEnumDeclaration(element)) return this.getInitializedValuesForEnum(element);
				return this.getInitializedValue(element, currentScope);
			});
			mapped.forEach((item, index) => {
				arr.push(item);
				if (index !== mapped.length - 1) arr.push(",");
			});
			arr.push("]");
			return this.flatten(arr);
		}

		if (this.isPropertyAccessExpression(statement) || this.isElementAccessExpression(statement)) {
			return this.getInitializedValuesForPropertyAccess(statement, currentScope);
		}

		if (this.isObjectLiteralDeclaration(statement)) {
			return this.getInitializedValuesForObjectLiteral(statement, currentScope);
		}

		if (this.isPropertyAssignment(statement)) {
			return this.getInitializedValue(statement, currentScope);
		}

		if (this.isTrueKeyword(statement)) {
			return [true];
		}

		if (this.isFalseKeyword(statement)) {
			return [false];
		}

		const isIdentifier = statement.constructor.name === "IdentifierObject";
		if ((<Identifier>statement).text == null) return null;
		const marshalled = this.marshaller.marshal((<Identifier>statement).text);
		return [isIdentifier
			? new BindingIdentifier((<Identifier>statement).text)
			: (typeof marshalled === "string" )
				? `\`${(<Identifier>statement).text}\``
				: (<Identifier>statement).text];
	}

	/**
	 * Flattens and returns an initialization value.
	 * @param {InitializationValue} value
	 * @param {boolean} [stringifyIdentifiers=false]
	 * @returns {string|null}
	 */
	public join (value: InitializationValue, stringifyIdentifiers: boolean = false): string | null {
		let str = "";
		value.map(item => {
			const trimmed = typeof item === "string" ? item.trim() : stringifyIdentifiers && item instanceof BindingIdentifier ? item.name : item;
			const whitespaced = trimmed === "new" ? `${trimmed} ` : trimmed;
			str += `${whitespaced}`;
		});
		return str;
	}

	/**
	 * Formats and returns a string representation of a type.
	 * @param {ParameterDeclaration|TypeAliasDeclaration|TypeNode} statement
	 * @returns {string|undefined}
	 */
	private normalizeTypeDeclaration (statement: ParameterDeclaration | TypeAliasDeclaration | TypeNode): string | undefined {
		if (this.isTypeNode(statement)) {

			if (this.isTypeReferenceNode(statement)) {
				// We have an identifier here.
				return (<Identifier>statement.typeName).text;
			}

			if (this.isArrayTypeNode(statement)) {
				return `${this.normalizeTypeDeclaration(statement.elementType)}[]`;
			}

			if (this.isTupleTypeNode(statement)) {
				return `[${statement.elementTypes.map(type => this.normalizeTypeDeclaration(type)).join(", ")}]`;
			}

			if (this.isIntersectionTypeNode(statement)) {
				return statement.types.map(intersectionType => this.normalizeTypeDeclaration(intersectionType)).join(" & ");
			}

			if (this.isUnionTypeNode(statement)) {
				return statement.types.map(unionType => this.normalizeTypeDeclaration(unionType)).join("|");
			}

			return this.serializeTypeKeyword(statement);
		} else {

			if (this.isTypeReference(statement)) {
				const typeName = statement.typeName;
				if (this.isIdentifierObject(typeName)) return typeName.text;
				return undefined;
			}

			return statement.type == null ? undefined : this.normalizeTypeDeclaration(statement.type);
		}
	}

	/**
	 * Gets a class declaration, including its methods, positions, which class it derives from,
	 * props and constructor arguments.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @param {string} filepath
	 * @param {string} fileContents
	 * @returns {IClassDeclaration}
	 */
	public getClassDeclaration (statement: Statement | Declaration | Expression | Node, filepath: string, fileContents: string): IClassDeclaration | null {
		if (!this.isClassDeclaration(statement) || statement.name == null) return null;

		const className = statement.name.text;
		const classDeclarationStartsAt = statement.pos;
		const classDeclarationEndsAt = statement.end;
		const classBodyStartsAt = fileContents.indexOf("{", classDeclarationStartsAt) + 1;
		const classBodyEndsAt = fileContents.indexOf("}", classDeclarationEndsAt - 1);
		const fullClassContents = fileContents.slice(classDeclarationStartsAt, classDeclarationEndsAt);
		const bodyClassContents = fileContents.slice(classBodyStartsAt, classBodyEndsAt);

		const declaration: IClassDeclaration = {
			name: className,
			filepath,
			methods: {},
			derives: null,
			constructorArguments: [],
			fullStartsAt: classDeclarationStartsAt,
			fullEndsAt: classDeclarationEndsAt,
			bodyStartsAt: classBodyStartsAt,
			bodyEndsAt: classBodyEndsAt,
			fullContents: fullClassContents,
			bodyContents: bodyClassContents,
			props: this.getClassProps(statement)
		};

		statement.members.forEach(member => {
			if (this.isConstructorDeclaration(member)) {
				member.parameters.forEach(parameter => {
					const name = (<Identifier>parameter.name).text;
					let type: string | undefined;
					let initializer: string | null = null;

					type = this.normalizeTypeDeclaration(parameter);

					const initValue = this.getInitializedValue(parameter, null);
					if (initValue != null) initializer = this.join(initValue, true);

					const startsAt = parameter.pos;
					const endsAt = parameter.end;
					declaration.constructorArguments.push({name, type, initializer, startsAt, endsAt});
				});
			}

			if (!this.isMethodDeclaration(member)) return;

			// TODO: Typescript doesn't think that a 'text' prop exists here. Who's right?
			const methodName = (<Identifier>member.name).text;

			const methodDeclarationStartsAt = member.pos;
			const methodDeclarationEndsAt = member.end;
			const methodBody = member.body;
			let methodBodyStartsAt = methodBody == null ? -1 : methodBody.pos;
			let methodBodyEndsAt = methodBody == null ? -1 : methodBody.end;
			const fullMethodContents = fileContents.slice(methodDeclarationStartsAt, methodDeclarationEndsAt);
			let bodyMethodContents = methodBody == null ? null : fileContents.slice(methodBodyStartsAt, methodBodyEndsAt);

			let returnStatementStartsAt: number = -1;
			let returnStatementEndsAt: number = -1;
			let returnStatementContents: string | null = null;
			let returnStatementTemplateStringContentsStartsAt: number = -1;
			let returnStatementTemplateStringContentsEndsAt: number = -1;
			let returnStatementTemplateStringContents: string | null = null;

			if (methodBody != null && methodBody.statements != null) {
				methodBody.statements.forEach(methodBodyStatement => {
					if (this.isReturnStatement(methodBodyStatement)) {
						if (methodBodyStatement.expression != null) {
							returnStatementStartsAt = methodBodyStatement.expression.pos;
							returnStatementEndsAt = methodBodyStatement.expression.end;
							returnStatementContents = fileContents.slice(returnStatementStartsAt, returnStatementEndsAt);
							if (this.isTemplateExpression(methodBodyStatement.expression)) {
								returnStatementTemplateStringContentsStartsAt = fileContents.indexOf("`", methodBodyStatement.expression.head.pos) + 1;
								returnStatementTemplateStringContentsEndsAt = methodBodyStatement.expression.templateSpans[methodBodyStatement.expression.templateSpans.length - 1].end - 1;
								returnStatementTemplateStringContents = fileContents.slice(returnStatementTemplateStringContentsStartsAt, returnStatementTemplateStringContentsEndsAt);
							} else if (this.isNoSubstitutionTemplateLiteral(methodBodyStatement.expression)) {
								returnStatementTemplateStringContentsStartsAt = fileContents.indexOf("`", methodBodyStatement.expression.pos) + 1;
								returnStatementTemplateStringContentsEndsAt = methodBodyStatement.expression.end - 1;
								returnStatementTemplateStringContents = fileContents.slice(returnStatementTemplateStringContentsStartsAt, returnStatementTemplateStringContentsEndsAt);
							}
						}
					}
				});
			}

			if (bodyMethodContents != null && bodyMethodContents.trim().startsWith("{")) {
				methodBodyStartsAt = fileContents.indexOf("{", methodBodyStartsAt) + 1;
				methodBodyEndsAt = fileContents.indexOf("}", methodBodyEndsAt - 1);
				bodyMethodContents = fileContents.slice(methodBodyStartsAt, methodBodyEndsAt);
			}

			declaration.methods[methodName] = {
				fullStartsAt: methodDeclarationStartsAt,
				fullEndsAt: methodDeclarationEndsAt,
				bodyStartsAt: methodBodyStartsAt,
				bodyEndsAt: methodBodyEndsAt,
				fullContents: fullMethodContents,
				bodyContents: bodyMethodContents,
				returnStatementStartsAt,
				returnStatementEndsAt,
				returnStatementContents,
				returnStatementTemplateStringContentsStartsAt,
				returnStatementTemplateStringContentsEndsAt,
				returnStatementTemplateStringContents
			};
		});

		if (statement.heritageClauses == null || statement.heritageClauses.length === 0) return declaration;

		let superClassName: string | null = null;
		for (const clause of statement.heritageClauses) {
			if (this.isExtendsKeyword(clause)) {
				const [type] = clause.types;
				// TODO: Why the need for casting? According to TS, text doesn't exist on this one.
				superClassName = (<Identifier>type.expression).text;
				declaration.derives = superClassName;
			}
		}
		return declaration;
	}

	/**
	 * Iterates through the parent chain and builds up a nested path to a property (e.g. 'this.is.a.member').
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {string}
	 */
	private extractParentPath (statement: Statement | Declaration | Expression | Node): string {
		let path = "";
		let current = statement.parent;

		while (current != null) {
			const name = this.getName(current);
			if (name != null) {
				path += this.isStatic(statement) ? `${name}.` : `${name}.prototype.`;
			}
			current = current.parent;
		}
		return path;
	}

	/**
	 * Checks for property accesses and returns the initialization values for them.
	 * @param {*} statement
	 * @param {string|null} currentScope
	 * @returns {NullableInitializationValue}
	 */
	/* tslint:disable */
	private getInitializedValuesForPropertyAccess (statement: any/*PropertyAccessExpression|ElementAccessExpression*/, currentScope: string | null): NullableInitializationValue {
		/* tslint:enable */
		let path = "";

		// TODO: Fix typings.
		let currentForProperty = statement.expression;
		if (currentForProperty == null) return null;
		while (currentForProperty != null && currentForProperty.text == null) {
			if (this.isThisKeyword(currentForProperty)) break;
			currentForProperty = currentForProperty.expression;
		}

		let currentForPath = statement;
		const argumentExpressions: string[] = [];
		while (currentForPath.expression != null) {
			const argument = currentForPath.argumentExpression;
			if (argument != null) argumentExpressions.push(`[${argument.text}]`);

			if (currentForPath.name != null) {
				path = `.${currentForPath.name.text}${path}`;
				if (argumentExpressions.length > 0) path += argumentExpressions.splice(0, 1)[0];
			}

			currentForPath = currentForPath.expression;
		}

		const text = this.isThisKeyword(currentForProperty)
			? currentScope != null
				? `${currentScope}.prototype`
				: "this"
			: currentForProperty.text;
		return (text == null && path == null) ? null : [new BindingIdentifier(`${text}${path}`)];
	}

	/**
	 * Checks for values associated with keys in an object literal and returns the initialization values.
	 * @param {ObjectLiteralExpression} statement
	 * @param {string|null} currentScope
	 * @returns {NullableInitializationValue}
	 */
	private getInitializedValuesForObjectLiteral (statement: ObjectLiteralExpression, currentScope: string | null): NullableInitializationValue {
		const props: { [key: string]: NullableInitializationValue } = {};
		statement.properties.forEach(prop => {

			const name = this.getName(prop);
			const value = this.getInitializedValue(prop, currentScope);

			if (name != null && value != null) {
				props[name] = value;
			}
		});
		return [props];
	}

	/**
	 * Finds a free enum ordinal value. Free meaning that no other member of the enumeration is initialized to that value.
	 * @param {Set<number>} taken
	 * @returns {number}
	 */
	private findFreeEnumIntegerValue (taken: Set<number>): number {
		const sorted = [...taken].sort();

		for (let i = 0; i < sorted.length; i++) {
			if (taken.has(i)) continue;
			return i;
		}
		return sorted.length;
	}

	/**
	 * Walks through an enumeration and checks the associated ordinal values.
	 * @param {EnumDeclaration} statement
	 * @returns NullableInitializationValue}
	 */
	private getInitializedValuesForEnum (statement: EnumDeclaration): NullableInitializationValue {
		const props: { [key: string]: NullableInitializationValue } = {};
		const taken: Set<number> = new Set();
		statement.members.forEach(member => {
			// TODO: Typescript doesn't think that a 'text' key exists here. Why?
			const value = (<Identifier>member.name).text;
			const initializer = member.initializer;
			// TODO: Remove any declaration.
			const integerValue = initializer == null ? this.findFreeEnumIntegerValue(taken) : parseInt((<any>initializer).text);

			taken.add(integerValue);

			if (value != null) props[value] = [integerValue];
		});
		return [props];
	}

	/**
	 * Flattens any amount of n-dimensional arrays.
	 * @param {...{}[]} arrays
	 * @returns {{}[]}
	 */
	private flatten (...arrays: {}[]): {}[] {
		return from(arrays);
	}

	/**
	 * Returns true if the given is not null and has length > 0.
	 * @param {NullableInitializationValue} value
	 * @returns {boolean}
	 */
	private initializedValueIsDefined (value: NullableInitializationValue): value is InitializationValue {
		return value != null && value.length > 0;
	}
}