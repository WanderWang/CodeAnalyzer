import {IMarshaller} from "@wessberg/marshaller";
import {dirname, join} from "path";
import * as ts from "typescript";
import {ArrayBindingPattern, AwaitExpression, ForOfStatement, TemplateMiddle, ForInStatement, ShorthandPropertyAssignment, DeleteExpression, EmptyStatement, RegularExpressionLiteral, DoStatement, ThrowStatement, BreakStatement, ContinueStatement, CaseClause, DefaultClause, SwitchStatement, CaseBlock, WhileStatement, VariableDeclarationList, BinaryOperator, PostfixUnaryExpression, ForStatement, CatchClause, TryStatement, ArrayLiteralExpression, TypeOfExpression, FunctionDeclaration, ClassExpression, NodeFlags, LabeledStatement, ArrayTypeNode, ArrowFunction, BinaryExpression, BindingName, BindingPattern, Block, BooleanLiteral, CallExpression, ClassDeclaration, CompilerOptions, ComputedPropertyName, ConditionalExpression, ConstructorDeclaration, Declaration, DeclarationName, ElementAccessExpression, EntityName, EnumDeclaration, ExportDeclaration, Expression, ExpressionStatement, FunctionExpression, HeritageClause, Identifier, ImportDeclaration, IndexSignatureDeclaration, IntersectionTypeNode, IScriptSnapshot, KeywordTypeNode, LanguageService, MethodDeclaration, ModuleKind, NamedImports, NewExpression, Node, NodeArray, NoSubstitutionTemplateLiteral, NumericLiteral, ObjectBindingPattern, ObjectLiteralExpression, ParameterDeclaration, ParenthesizedExpression, PrefixUnaryExpression, PropertyAccessExpression, PropertyAssignment, PropertyDeclaration, PropertyName, PropertySignature, ReturnStatement, ScriptTarget, SpreadAssignment, SpreadElement, Statement, StringLiteral, TemplateExpression, TemplateHead, TemplateSpan, TemplateTail, ThisExpression, Token, TupleTypeNode, TypeAliasDeclaration, TypeAssertion, TypeLiteralNode, TypeNode, TypeReferenceNode, UnionTypeNode, VariableStatement, SyntaxKind, SourceFile, IfStatement, VariableDeclaration, ExpressionWithTypeArguments} from "typescript";
import {BindingIdentifier} from "./BindingIdentifier";
import {ArbitraryValue, VariableIndexer, IArgument, DecoratorIndexer, ClassIndexer, ICallExpression, IClassDeclaration, IConstructorDeclaration, IHeritage, IMemberDeclaration, IMethodDeclaration, IModuleDependency, InitializationValue, IParameter, IParametersable, IPropDeclaration, ISimpleLanguageService, ITypeBinding, TypeExpression, INewExpression, ITypeable, ICallable, ISourceFileProperties} from "./interface/ISimpleLanguageService";
import {ISimpleLanguageServiceConfig} from "./interface/ISimpleLanguageServiceConfig";
import { IBindingIdentifier } from "src/interface/IBindingIdentifier";

/**
 * A service that parses and reflects on the AST generated by Typescript's language service.
 * With it, we can extract metadata such as initialization values and types, arguments and import
 * declarations.
 * @author Frederik Wessberg
 */
export class SimpleLanguageService implements ISimpleLanguageService {
	private languageService: LanguageService;
	private files: Map<string, { version: number, content: string }> = new Map();

	constructor (private marshaller: IMarshaller,
							 private config: ISimpleLanguageServiceConfig = {},
							 private typescript: typeof ts = ts) {
		this.languageService = this.typescript.createLanguageService(this, typescript.createDocumentRegistry());
	}

	/**
	 * Adds a new file to the LanguageService.
	 * @param {string} fileName
	 * @param {string} content
	 * @param {number} [version=0]
	 * @returns {NodeArray<Statement>}
	 */
	public addFile (fileName: string, content: string, version: number = 0): NodeArray<Statement> {
		this.files.set(fileName, {version, content});
		return this.getFile(fileName);
	}

	/**
	 * Gets the Statements associated with the given filename.
	 * @param {string} fileName
	 * @returns {NodeArray<Statement>}
	 */
	public getFile(fileName: string): NodeArray<Statement> {
		return this.languageService.getProgram().getSourceFile(fileName).statements;
	}

	/**
	 * Gets the settings that Typescript will generate an AST from. There isn't much reason to make
	 * anything but the libs developer-facing since we only support ES2015 modules.
	 * @returns {CompilerOptions}
	 */
	public getCompilationSettings (): CompilerOptions {
		return {
			target: ScriptTarget.ES2017,
			module: ModuleKind.ES2015,
			lib: this.config.lib != null && this.config.lib.length > 0
				? this.config.lib
				: ["es2015.promise", "dom", "es6", "scripthost", "es7", "es2017.object", "es2015.proxy"]
		};
	}

	/**
	 * Gets the names of each file that has been added to the "program".
	 * @returns {string[]}
	 */
	public getScriptFileNames (): string[] {
		return [...this.files.keys()];
	}

	/**
	 * Gets the last version of the given fileName. Each time a file changes, the version number will be updated,
	 * so this can be useful to figure out if the file has changed since the program was run initially.
	 * @param {string} fileName
	 * @returns {string}
	 */
	public getScriptVersion (fileName: string): string {
		const script = this.files.get(fileName);
		if (script == null) return "-1";
		return script.version.toString();
	}

	/**
	 * Gets the last registered IScriptSnapshot, if any, otherwise undefined.
	 * @param {string} fileName
	 * @returns {IScriptSnapshot?}
	 */
	public getScriptSnapshot (fileName: string): IScriptSnapshot | undefined {
		const file = this.files.get(fileName);
		if (file == null) return undefined;
		return this.typescript.ScriptSnapshot.fromString(file.content);
	}

	/**
	 * Gets the current directory.
	 * @returns {string}
	 */
	public getCurrentDirectory (): string {
		return process.cwd();
	}

	/**
	 * Gets the default filepath for Typescript's lib-files.
	 * @param {CompilerOptions} options
	 * @returns {string}
	 */
	public getDefaultLibFileName (options: CompilerOptions): string {
		return this.typescript.getDefaultLibFilePath(options);
	}

	/**
	 * A predicate function that returns true if the given Statement is an ObjectLiteralExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isObjectLiteralExpression (statement: Statement | Declaration | Expression | Node): statement is ObjectLiteralExpression {
		return statement.kind === SyntaxKind.ObjectLiteralExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a VariableStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isVariableStatement (statement: Statement | Declaration | Expression | Node): statement is VariableStatement {
		return statement.kind === SyntaxKind.VariableStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a VariableDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isVariableDeclaration (statement: Statement | Declaration | Expression | Node): statement is VariableDeclaration {
		return statement.kind === SyntaxKind.VariableDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is a PropertyAccessExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPropertyAccessExpression (statement: Statement | Declaration | Expression | Node): statement is PropertyAccessExpression {
		return statement.kind === SyntaxKind.PropertyAccessExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a PropertyDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPropertyDeclaration (statement: Statement | Declaration | Expression | Node): statement is PropertyDeclaration {
		return statement.kind === SyntaxKind.PropertyDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is a PropertySignature.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPropertySignature (statement: Statement | Declaration | Expression | Node): statement is PropertySignature {
		return statement.kind === SyntaxKind.PropertySignature;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ElementAccessExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isElementAccessExpression (statement: Statement | Declaration | Expression | Node): statement is ElementAccessExpression {
		return statement.kind === SyntaxKind.ElementAccessExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ArrayLiteralExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isArrayLiteralExpression (statement: Statement | Declaration | Expression | Node): statement is ArrayLiteralExpression {
		return statement.kind === SyntaxKind.ArrayLiteralExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeAssertion.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTypeAssertionExpression (statement: Statement | Declaration | Expression | Node): statement is TypeAssertion {
		return statement.kind === SyntaxKind.TypeAssertionExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an NoSubstitutionTemplateLiteral.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNoSubstitutionTemplateLiteral (statement: Statement | Declaration | Expression | Node): statement is NoSubstitutionTemplateLiteral {
		return statement.kind === SyntaxKind.NoSubstitutionTemplateLiteral;
	}

	/**
	 * A predicate function that returns true if the given Statement is a a TemplateExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTemplateExpression (statement: Statement | Declaration | Expression | Node): statement is TemplateExpression {
		return statement.kind === SyntaxKind.TemplateExpression || statement.kind === SyntaxKind.TaggedTemplateExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a an ArrowFunction.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isArrowFunction (statement: Statement | Declaration | Expression | Node): statement is ArrowFunction {
		return statement.kind === SyntaxKind.ArrowFunction;
	}

	/**
	 * A predicate function that returns true if the given Statement is a a LabeledStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isLabeledStatement (statement: Statement | Declaration | Expression | Node): statement is LabeledStatement {
		return statement.kind === SyntaxKind.LabeledStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a FunctionExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isFunctionExpression (statement: Statement | Declaration | Expression | Node): statement is FunctionExpression {
		return statement.kind === SyntaxKind.FunctionExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a FunctionDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isFunctionDeclaration (statement: Statement | Declaration | Expression | Node): statement is FunctionDeclaration {
		return statement.kind === SyntaxKind.FunctionDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is an AwaitExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isAwaitExpression (statement: Statement | Declaration | Expression | Node): statement is AwaitExpression {
		return statement.kind === SyntaxKind.AwaitExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an TemplateSpan.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTemplateSpan (statement: Statement | Declaration | Expression | Node): statement is TemplateSpan {
		return statement.kind === SyntaxKind.TemplateSpan;
	}

	/**
	 * A predicate fuction that returns true if the given Statement is an ConditionalExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {booean}
	 */
	public isConditionalExpression (statement: Statement | Declaration | Expression | Node): statement is ConditionalExpression {
		return statement.kind === SyntaxKind.ConditionalExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an CallExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isCallExpression (statement: Statement | Declaration | Expression | Node): statement is CallExpression {
		return statement.kind === SyntaxKind.CallExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a PrefixUnaryExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPrefixUnaryExpression (statement: Statement | Declaration | Expression | Node): statement is PrefixUnaryExpression {
		return statement.kind === SyntaxKind.PrefixUnaryExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a PostfixUnaryExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPostfixUnaryExpression (statement: Statement | Declaration | Expression | Node): statement is PostfixUnaryExpression {
		return statement.kind === SyntaxKind.PostfixUnaryExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeOfExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTypeOfExpression (statement: Statement | Declaration | Expression | Node): statement is TypeOfExpression {
		return statement.kind === SyntaxKind.TypeOfExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TryStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTryStatement (statement: Statement | Declaration | Expression | Node): statement is TryStatement {
		return statement.kind === SyntaxKind.TryStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a CatchClause.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isCatchClause (statement: Statement | Declaration | Expression | Node): statement is CatchClause {
		return statement.kind === SyntaxKind.CatchClause;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ParenthesizedExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 */
	public isParenthesizedExpression (statement: Statement | Declaration | Expression | Node): statement is ParenthesizedExpression {
		return statement.kind === SyntaxKind.ParenthesizedExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ParameterDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isParameterDeclaration (statement: Statement | Declaration | Expression | Node): statement is ParameterDeclaration {
		return statement.kind === SyntaxKind.Parameter;
	}

	/**
	 * A predicate function that returns true if the given Statement is a BinaryExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isBinaryExpression (statement: Statement | Declaration | Expression | Node): statement is BinaryExpression {
		return statement.kind === SyntaxKind.BinaryExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ImportDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isImportDeclaration (statement: Statement | Declaration | Expression | Node): statement is ImportDeclaration {
		return statement.kind === SyntaxKind.ImportDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is an IfStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isIfStatement (statement: Statement | Declaration | Expression | Node): statement is IfStatement {
		return statement.kind === SyntaxKind.IfStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is am EnumDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isEnumDeclaration (statement: Statement | Declaration | Expression | Node): statement is EnumDeclaration {
		return statement.kind === SyntaxKind.EnumDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'true'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTrueKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is BooleanLiteral {
		return statement.kind === SyntaxKind.TrueKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'false'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isFalseKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is BooleanLiteral {
		return statement.kind === SyntaxKind.FalseKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'undefined'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isUndefinedKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.UndefinedKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'null'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNullKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.NullKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'string'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isStringKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.StringKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'symbol'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isSymbolKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.SymbolKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'void'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isVoidKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.VoidKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'any'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isAnyKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.AnyKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'boolean'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isBooleanKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.BooleanKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'never'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNeverKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.NeverKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'number'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNumberKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.NumberKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is a NumericLiteral.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNumericLiteral (statement: TypeNode | Statement | Declaration | Expression | Node): statement is NumericLiteral {
		return statement.kind === SyntaxKind.NumericLiteral;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ObjectBindingPattern.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isObjectBindingPattern (statement: TypeNode | Statement | Declaration | Expression | Node): statement is ObjectBindingPattern {
		return statement.kind === SyntaxKind.ObjectBindingPattern;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ArrayBindingPattern.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isArrayBindingPattern (statement: TypeNode | Statement | Declaration | Expression | Node): statement is ArrayBindingPattern {
		return statement.kind === SyntaxKind.ArrayBindingPattern;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ArrayBindingPattern.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isBindingPattern (statement: TypeNode | Statement | Declaration | Expression | Node): statement is BindingPattern {
		return this.isObjectBindingPattern(statement) || this.isArrayBindingPattern(statement);
	}

	/**
	 * A predicate function that returns true if the given Statement is a PropertyName.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPropertyName (statement: Expression | Node): statement is PropertyName {
		return this.isIdentifierObject(statement) ||
			this.isStringLiteral(statement) ||
			this.isNumericLiteral(statement) ||
			this.isComputedPropertyName(statement);
	}

	/**
	 * A predicate function that returns true if the given Statement is a DeclarationName.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isDeclarationName (statement: Expression | Node): statement is DeclarationName {
		return this.isPropertyName(statement) || this.isBindingPattern(statement);
	}

	/**
	 * A predicate function that returns true if the given Statement is a TemplateHead.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTemplateHead (statement: TypeNode | Statement | Declaration | Expression | Node): statement is TemplateHead {
		return statement.kind === SyntaxKind.TemplateHead;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TemplateMiddle.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTemplateMiddle (statement: TypeNode | Statement | Declaration | Expression | Node): statement is TemplateMiddle {
		return statement.kind === SyntaxKind.TemplateMiddle;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TemplateTail.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTemplateTail (statement: TypeNode | Statement | Declaration | Expression | Node): statement is TemplateTail {
		return statement.kind === SyntaxKind.TemplateTail;
	}

	/**
	 * A predicate function that returns true if the given Statement is a StringLiteral.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isStringLiteral (statement: TypeNode | Statement | Declaration | Expression | Node): statement is StringLiteral {
		return statement.kind === SyntaxKind.StringLiteral;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'object'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isObjectKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.ObjectKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'this'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isThisKeyword (statement: Statement | Declaration | Expression | Node): statement is ThisExpression {
		return statement.kind === SyntaxKind.ThisKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ForStatement
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isForStatement (statement: Statement | Declaration | Expression | Node): statement is ForStatement {
		return statement.kind === SyntaxKind.ForStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ForOfStatement
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isForOfStatement (statement: Statement | Declaration | Expression | Node): statement is ForOfStatement {
		return statement.kind === SyntaxKind.ForOfStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ForInStatement
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isForInStatement (statement: Statement | Declaration | Expression | Node): statement is ForInStatement {
		return statement.kind === SyntaxKind.ForInStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a SwitchStatement.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isSwitchStatement (statement: Statement | Declaration | Expression | Node): statement is SwitchStatement {
		return statement.kind === SyntaxKind.SwitchStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a CaseBlock.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isCaseBlock (statement: Statement | Declaration | Expression | Node): statement is CaseBlock {
		return statement.kind === SyntaxKind.CaseBlock;
	}	

	/**
	 * A predicate function that returns true if the given Statement is a WhileStatement.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isWhileStatement (statement: Statement | Declaration | Expression | Node): statement is WhileStatement {
		return statement.kind === SyntaxKind.WhileStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a VariableDeclarationList.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isVariableDeclarationList (statement: Statement | Declaration | Expression | Node): statement is VariableDeclarationList {
		return statement.kind === SyntaxKind.VariableDeclarationList;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeNode
	 * @param {ParameterDeclaration|TypeAliasDeclaration|TypeNode} statement
	 * @returns {boolean}
	 */
	public isTypeNode (statement: ParameterDeclaration | TypeAliasDeclaration | TypeNode): statement is TypeNode {
		return this.isThisKeyword(statement) ||
			this.isArrayTypeNode(statement) ||
			this.isTupleTypeNode(statement) ||
			this.isIntersectionTypeNode(statement) ||
			this.isUnionTypeNode(statement) ||
			this.isObjectKeyword(statement) ||
			this.isNumberKeyword(statement) ||
			this.isNeverKeyword(statement) ||
			this.isBooleanKeyword(statement) ||
			this.isAnyKeyword(statement) ||
			this.isVoidKeyword(statement) ||
			this.isSymbolKeyword(statement) ||
			this.isStringKeyword(statement) ||
			this.isNullKeyword(statement) ||
			this.isUndefinedKeyword(statement) ||
			this.isTrueKeyword(statement) ||
			this.isFalseKeyword(statement);
	}

	/**
	 * A predicate function that returns true if the given Statement is a PropertyAssignment.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPropertyAssignment (statement: Statement | Declaration | Expression | Node): statement is PropertyAssignment {
		return statement.kind === SyntaxKind.PropertyAssignment;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ExpressionStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isExpressionStatement(statement: Statement | Declaration | Expression | Node): statement is ExpressionStatement {
		return statement.kind === SyntaxKind.ExpressionStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a SpreadAssignment.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isSpreadAssignment (statement: Statement | Declaration | Expression | Node): statement is SpreadAssignment {
		return statement.kind === SyntaxKind.SpreadAssignment;
	}

	/**
	 * A predicate function that returns true if the given Statement is a SpreadElement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isSpreadElement (statement: Statement | Declaration | Expression | Node): statement is SpreadElement {
		return statement.kind === SyntaxKind.SpreadElement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeReferenceNode.
	 * @param {ParameterDeclaration|TypeReferenceNode|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isTypeReference (statement: ParameterDeclaration | TypeReferenceNode | TypeNode | TypeAliasDeclaration): statement is TypeReferenceNode {
		return statement.kind === SyntaxKind.TypeReference;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ExpressionWithTypeArguments.
	 * @param {ParameterDeclaration|TypeReferenceNode|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isExpressionWithTypeArguments (statement: ParameterDeclaration | TypeReferenceNode | TypeNode | TypeAliasDeclaration): statement is ExpressionWithTypeArguments {
		return statement.kind === SyntaxKind.ExpressionWithTypeArguments;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeLiteralNode.
	 * @param {ParameterDeclaration|TypeReferenceNode|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isTypeLiteralNode (statement: ParameterDeclaration | TypeReferenceNode | TypeNode | TypeAliasDeclaration): statement is TypeLiteralNode {
		return statement.kind === SyntaxKind.TypeLiteral;
	}

	/**
	 * A predicate function that returns true if the given Statement is an IndexSignatureDeclaration.
	 * @param {ParameterDeclaration|TypeReferenceNode|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isIndexSignatureDeclaration (statement: Declaration): statement is IndexSignatureDeclaration {
		return statement.kind === SyntaxKind.IndexSignature;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ClassDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isClassDeclaration (statement: Statement | Declaration | Expression | Node): statement is ClassDeclaration {
		return statement.kind === SyntaxKind.ClassDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ClassExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isClassExpression (statement: Statement | Declaration | Expression | Node): statement is ClassExpression {
		return statement.kind === SyntaxKind.ClassExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ConstructorDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isConstructorDeclaration (statement: Statement | Declaration | Expression | Node): statement is ConstructorDeclaration {
		return statement.kind === SyntaxKind.Constructor;
	}

	/**
	 * A predicate function that returns true if the given Statement is a EmptyStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isEmptyStatement (statement: Statement | Declaration | Expression | Node): statement is EmptyStatement {
		return statement.kind === SyntaxKind.EmptyStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a DeleteExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isDeleteExpression (statement: Statement | Declaration | Expression | Node): statement is DeleteExpression {
		return statement.kind === SyntaxKind.DeleteExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeReferenceNode.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTypeReferenceNode (statement: Statement | Declaration | Expression | Node): statement is TypeReferenceNode {
		return statement.kind === SyntaxKind.TypeReference;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ArrayTypeNode.
	 * @param {ParameterDeclaration|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isArrayTypeNode (statement: ParameterDeclaration | TypeNode | TypeAliasDeclaration): statement is ArrayTypeNode {
		return statement.kind === SyntaxKind.ArrayType;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TupleTypeNode.
	 * @param {ParameterDeclaration|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isTupleTypeNode (statement: ParameterDeclaration | TypeNode | TypeAliasDeclaration): statement is TupleTypeNode {
		return statement.kind === SyntaxKind.TupleType;
	}

	/**
	 * A predicate function that returns true if the given Statement is a UnionTypeNode.
	 * @param {ParameterDeclaration|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isUnionTypeNode (statement: ParameterDeclaration | TypeNode | TypeAliasDeclaration): statement is UnionTypeNode {
		return statement.kind === SyntaxKind.UnionType;
	}

	/**
	 * A predicate function that returns true if the given Statement is a IntersectionTypeNode.
	 * @param {ParameterDeclaration|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isIntersectionTypeNode (statement: ParameterDeclaration | TypeNode | TypeAliasDeclaration): statement is IntersectionTypeNode {
		return statement.kind === SyntaxKind.IntersectionType;
	}

	/**
	 * A predicate function that returns true if the given Statement is a MethodDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isMethodDeclaration (statement: Statement | Declaration | Expression | Node): statement is MethodDeclaration {
		return statement.kind === SyntaxKind.MethodDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is a NewExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNewExpression (statement: Statement | Declaration | Expression | Node): statement is NewExpression {
		return statement.kind === SyntaxKind.NewExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a Block.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isBlockDeclaration (statement: Statement | Declaration | Expression | Node): statement is Block {
		return statement.kind === SyntaxKind.Block;
	}

	/**
	 * A predicate function that returns true if the given Statement is a BreakStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isBreakStatement (statement: Statement | Declaration | Expression | Node): statement is BreakStatement {
		return statement.kind === SyntaxKind.BreakStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ThrowStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isThrowStatement (statement: Statement | Declaration | Expression | Node): statement is ThrowStatement {
		return statement.kind === SyntaxKind.ThrowStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a DoStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isDoStatement (statement: Statement | Declaration | Expression | Node): statement is DoStatement {
		return statement.kind === SyntaxKind.DoStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ContinueStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isContinueStatement (statement: Statement | Declaration | Expression | Node): statement is ContinueStatement {
		return statement.kind === SyntaxKind.ContinueStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ReturnStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isReturnStatement (statement: Statement | Declaration | Expression | Node): statement is ReturnStatement {
		return statement.kind === SyntaxKind.ReturnStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ExportDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isExportDeclaration (statement: Statement | Declaration | Expression | Node): statement is ExportDeclaration {
		return statement.kind === SyntaxKind.ExportDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is a SourceFile.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isSourceFile (statement: Statement | Declaration | Expression | Node): statement is SourceFile {
		return statement.kind === SyntaxKind.SourceFile;
	}

	/**
	 * A predicate function that returns true if the given Statement is a FirstLiteralToken|LastLiteralToken.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isLiteralToken (statement: Statement | Declaration | Expression | Node): statement is Token<SyntaxKind.FirstLiteralToken|SyntaxKind.LastLiteralToken> {
		return statement.kind === SyntaxKind.FirstLiteralToken || statement.kind === SyntaxKind.LastLiteralToken;
	}

	/**
	 * A predicate function that returns true if the given Statement is a FirstLiteralToken|LastLiteralToken.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTemplateToken (statement: Statement | Declaration | Expression | Node): statement is Token<SyntaxKind.FirstTemplateToken|SyntaxKind.LastTemplateToken> {
		return statement.kind === SyntaxKind.FirstTemplateToken || statement.kind === SyntaxKind.LastTemplateToken;
	}

	/**
	 * A predicate function that returns true if the given Statement is an Identifier.
	 * @param {BindingName|EntityName|Expression} statement
	 * @returns {boolean}
	 */
	public isIdentifierObject (statement: BindingName | EntityName | Expression | Node): statement is Identifier {
		return statement != null && statement.constructor.name === "IdentifierObject";
	}

	/**
	 * A predicate function that returns true if the given Statement is a TokenObject.
	 * @param {BindingName|EntityName|Expression} statement
	 * @returns {boolean}
	 */
	public isTokenObject (statement: BindingName | EntityName | Expression | Node): statement is Token<SyntaxKind> {
		return statement != null && statement.constructor.name === "TokenObject";
	}

	/**
	 * A predicate function that returns true if the given Statement is a RegularExpressionLiteral.
	 * @param {BindingName|EntityName|Expression} statement
	 * @returns {boolean}
	 */
	public isRegularExpressionLiteral (statement: BindingName | EntityName | Expression | Node): statement is RegularExpressionLiteral {
		return statement.kind === SyntaxKind.RegularExpressionLiteral;
	}

	/**
	 * A predicate function that returns true if the given Statement is a FirstLiteralToken.
	 * @param {BindingName|EntityName|Expression} statement
	 * @returns {boolean}
	 */
	public isFirstLiteralToken (statement: BindingName | EntityName | Expression | Node): statement is Token<SyntaxKind.FirstLiteralToken> & { text: string } {
		return statement.kind === SyntaxKind.FirstLiteralToken;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ShorthandPropertyAssignment.
	 * @param {BindingName|EntityName|Expression} statement
	 * @returns {boolean}
	 */
	public isShorthandPropertyAssignment (statement: BindingName | EntityName | Expression | Node): statement is ShorthandPropertyAssignment {
		return statement.kind === SyntaxKind.ShorthandPropertyAssignment;
	}

	/**
	 * A predicate function that returns true if the given Statement is a CaseClause.
	 * @param {BindingName|EntityName|Expression} statement
	 * @returns {boolean}
	 */
	public isCaseClause (statement: BindingName | EntityName | Expression | Node): statement is CaseClause {
		return statement.kind === SyntaxKind.CaseClause;
	}

	/**
	 * A predicate function that returns true if the given Statement is a DefaultClause.
	 * @param {BindingName|EntityName|Expression} statement
	 * @returns {boolean}
	 */
	public isDefaultClause (statement: BindingName | EntityName | Expression | Node): statement is DefaultClause {
		return statement.kind === SyntaxKind.DefaultClause;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ComputedPropertyName.
	 * @param {BindingName|EntityName|Expression} statement
	 * @returns {boolean}
	 */
	public isComputedPropertyName (statement: BindingName | EntityName | Expression | Node): statement is ComputedPropertyName {
		return statement.kind === SyntaxKind.ComputedPropertyName;
	}

	/**
	 * A predicate function that returns true if the given Statement is a HeritageClause.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isExtendsClause (statement: Statement | Declaration | Expression | Node): statement is HeritageClause {
		// Extends will always be a 'token', not a 'kind'.
		return (<HeritageClause>statement).token === SyntaxKind.ExtendsKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is a HeritageClause.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isImplementsClause (statement: Statement | Declaration | Expression | Node): statement is HeritageClause {
		// Extends will always be a 'token', not a 'kind'.
		return (<HeritageClause>statement).token === SyntaxKind.ImplementsKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is a NamedImports expression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNamedImports (statement: Statement | Declaration | Expression | Node): statement is NamedImports {
		// Extends will always be a 'token', not a 'kind'.
		return statement.kind === SyntaxKind.NamedImports;
	}

	/**
	 * A predicate function that returns true if an expression is a ITypeBinding.
	 * @param {ArbitraryValue} expression
	 * @returns {boolean}
	 */
	private isTypeBinding (expression: ArbitraryValue): expression is ITypeBinding {
		const exp = <ITypeBinding>expression;
		return exp.name != null && (exp.typeArguments === null || Array.isArray(exp.typeArguments));
	}

	/**
	 * Checks the token and returns the appropriate native version if possible, otherwise it returns the serialized version.
	 * @param {SyntaxKind} token
	 * @returns {ArbitraryValue}
	 */
	public marshalToken (token: SyntaxKind|BinaryOperator|TypeNode): ArbitraryValue {
		switch (token) {
			case SyntaxKind.NullKeyword:
				return null;
			case SyntaxKind.UndefinedKeyword:
				return undefined;
			case SyntaxKind.TrueKeyword:
				return true;
			case SyntaxKind.FalseKeyword:
				return false;
			default:
				return this.serializeToken(token);
		}
	}

	/**
	 * Serializes the given flag and returns the textual representation of it.
	 * @param {NodeFlags} flag
	 * @returns {string|null}
	 */
	public serializeFlag(flag: NodeFlags): string|null {
		switch (flag) {
			case NodeFlags.Const:
				return "const";
			case NodeFlags.Let:
				return "let";
		}
		return null;
	}

	/**
	 * Returns true if the given item is a stringified operator.
	 * @param {ArbitraryValue} item
	 * @returns {boolean}
	 */	
	private isOperatorLike(item: ArbitraryValue): boolean {
		switch (item == null ? "" : item.toString()) {
			case "+":
			case "-":
			case "=":
			case "=>":
			case "==":
			case "===":
			case "++":
			case "--":
			case "+=":
			case "-=":
			case "*":
			case "/":
			case "*=":
			case "**=":
			case "**":
			case "!==":
			case "!=":
			case "!":
			case "||":
			case "|":
			case "|=":
			case "&&":
			case "&":
			case "&=":
			case "%":
			case "/=":
			case "</":
			case "%=":
			case ":":
			case ";":
			case "<=":
			case ">":
			case "<":
			case "<<=":
			case "<<":
			case ">=":
			case ">>=":
			case ">>>":
			case "<<<":
			case ">>":
			case ">>>=":
			case "?":
			case "~":
			case "^":
			case "^=":
			case ",":	
			case "{":
			case "}":
			case "(":
			case ")":
			case "[":
			case "]":
			case ".":	
			case "...":
				return true;	
			default:
			return false;
		}
	}

	/**
	 * Serializes the given token (operand) and returns the textual representation of it.
	 * @param {SyntaxKind} token
	 * @returns {string|BindingIdentifier}
	 */
	public serializeToken(token: ts.SyntaxKind | TypeNode): string|IBindingIdentifier {
		switch (token) {
			case SyntaxKind.BreakStatement:
				return "break";
			case SyntaxKind.ThrowStatement:
				return "throw";
			case SyntaxKind.DoStatement:
				return "do";
			case SyntaxKind.ContinueStatement:
				return "continue";	
			case SyntaxKind.ObjectKeyword:
				return "object";
			case SyntaxKind.NumberKeyword:
				return "number";
			case SyntaxKind.NeverKeyword:
				return "never";
			case SyntaxKind.BooleanKeyword:
				return "boolean";
			case SyntaxKind.AnyKeyword:
				return "any";
			case SyntaxKind.VoidKeyword:
				return "void";
			case SyntaxKind.SymbolKeyword:
				return "symbol";
			case SyntaxKind.NullKeyword:
				return "null";
			case SyntaxKind.UndefinedKeyword:
				return "undefined";
			case SyntaxKind.StringKeyword:
				return "string";
			case SyntaxKind.TrueKeyword:
				return "true";
			case SyntaxKind.FalseKeyword:
				return "false";
			case SyntaxKind.BreakKeyword:
				return "break";
			case SyntaxKind.CatchKeyword:
				return "catch";
			case SyntaxKind.CaseKeyword:
				return "case";
			case SyntaxKind.ClassKeyword:
				return "class";
			case SyntaxKind.ConstKeyword:
				return "const";
			case SyntaxKind.ContinueKeyword:
				return "continue";
			case SyntaxKind.DebuggerKeyword:
				return "debugger";
			case SyntaxKind.DefaultKeyword:
				return "default";
			case SyntaxKind.DeleteKeyword:
				return "delete";
			case SyntaxKind.DeleteExpression:
				return "delete";
			case SyntaxKind.DoKeyword:
				return "do";
			case SyntaxKind.ElseKeyword:
				return "else";
			case SyntaxKind.EnumKeyword:
				return "enum";
			case SyntaxKind.ExportKeyword:
				return "export";
			case SyntaxKind.ExtendsKeyword:
				return "extends";
			case SyntaxKind.FinallyKeyword:
				return "finally";
			case SyntaxKind.ForKeyword:
				return "for";
			case SyntaxKind.FunctionKeyword:
				return "function";
			case SyntaxKind.IfKeyword:
				return "if";
			case SyntaxKind.ImportKeyword:
				return "import";
			case SyntaxKind.InKeyword:
				return "in";
			case SyntaxKind.InstanceOfKeyword:
				return "instanceof";
			case SyntaxKind.NewKeyword:
				return "new";
			case SyntaxKind.ReturnKeyword:
			case SyntaxKind.ReturnStatement:
				return "return";
			case SyntaxKind.SuperKeyword:
				return "super";
			case SyntaxKind.ThisKeyword:
				return  new BindingIdentifier("this");
			case SyntaxKind.ThrowKeyword:
				return "throw";
			case SyntaxKind.TryKeyword:
				return "try";
			case SyntaxKind.TypeOfKeyword:
				return "typeof";
			case SyntaxKind.VarKeyword:
				return "var";
			case SyntaxKind.WithKeyword:
				return "with";
			case SyntaxKind.ImplementsKeyword:
				return "implements";
			case SyntaxKind.InterfaceKeyword:
				return "interface";
			case SyntaxKind.LetKeyword:
				return "let";
			case SyntaxKind.PackageKeyword:
				return "package";
			case SyntaxKind.PrivateKeyword:
				return "private";
			case SyntaxKind.ProtectedKeyword:
				return "protected";
			case SyntaxKind.PublicKeyword:
				return "public";
			case SyntaxKind.StaticKeyword:
				return "static";
			case SyntaxKind.YieldKeyword:
				return "yield";
			case SyntaxKind.AbstractKeyword:
				return "abstract";
			case SyntaxKind.AsKeyword:
				return "as";
			case SyntaxKind.AsyncKeyword:
				return "async";
			case SyntaxKind.AwaitKeyword:
				return "await";
			case SyntaxKind.ConstructorKeyword:
				return "constructor";
			case SyntaxKind.DeclareKeyword:
				return "declare";
			case SyntaxKind.GetKeyword:
				return "get";
			case SyntaxKind.IsKeyword:
				return "is";
			case SyntaxKind.KeyOfKeyword:
				return "keyof";
			case SyntaxKind.ModuleKeyword:
				return "module";
			case SyntaxKind.NamespaceKeyword:
				return "namespace";
			case SyntaxKind.ReadonlyKeyword:
				return "readonly";
			case SyntaxKind.RequireKeyword:
				return "require";
			case SyntaxKind.SetKeyword:
				return "set";
			case SyntaxKind.TypeKeyword:
				return "type";
			case SyntaxKind.FromKeyword:
				return "from";
			case SyntaxKind.GlobalKeyword:
				return "global";
			case SyntaxKind.OfKeyword:
				return "of";
			case SyntaxKind.MinusToken:
				return "-";
			case SyntaxKind.PlusToken:
				return "+";
			case SyntaxKind.PlusPlusToken:
				return "++";
			case SyntaxKind.MinusMinusToken:
				return "--";
			case SyntaxKind.PlusEqualsToken:
				return "+=";
			case SyntaxKind.MinusEqualsToken:
				return "-=";
			case SyntaxKind.AsteriskToken:
				return "*";
			case SyntaxKind.AtToken:
				return "@";
			case SyntaxKind.EqualsEqualsEqualsToken:
				return "===";
			case SyntaxKind.EqualsEqualsToken:
				return "==";
			case SyntaxKind.EqualsGreaterThanToken:
				return "=>";
			case SyntaxKind.EqualsToken:
				return "=";
			case SyntaxKind.AsteriskEqualsToken:
				return "*=";
			case SyntaxKind.AsteriskAsteriskEqualsToken:
				return "**=";
			case SyntaxKind.ExclamationEqualsEqualsToken:
				return "!==";
			case SyntaxKind.ExclamationEqualsToken:
				return "!=";
			case SyntaxKind.ExclamationToken:
				return "!";
			case SyntaxKind.BarBarToken:
				return "||";
			case SyntaxKind.BarToken:
				return "|";
			case SyntaxKind.BarEqualsToken:
				return "|=";
			case SyntaxKind.AmpersandAmpersandToken:
				return "&&";
			case SyntaxKind.AmpersandEqualsToken:
				return "&=";
			case SyntaxKind.AmpersandToken:
				return "&";
			case SyntaxKind.SlashEqualsToken:
				return "/=";
			case SyntaxKind.SlashToken:
				return "/";
			case SyntaxKind.LessThanSlashToken:
				return "</";
			case SyntaxKind.PercentToken:
				return "%";
			case SyntaxKind.PercentEqualsToken:
				return "%=";
			case SyntaxKind.ColonToken:
				return ":";
			case SyntaxKind.SemicolonToken:
				return ";";
			case SyntaxKind.LessThanEqualsToken:
				return "<=";
			case SyntaxKind.LessThanToken:
				return "<";
			case SyntaxKind.LessThanLessThanEqualsToken:
				return "<<=";
			case SyntaxKind.LessThanLessThanToken:
				return "<<";
			case SyntaxKind.GreaterThanEqualsToken:
				return ">=";
			case SyntaxKind.GreaterThanGreaterThanEqualsToken:
				return ">>=";
			case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
				return ">>>";
			case SyntaxKind.GreaterThanGreaterThanToken:
				return ">>";
			case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
				return ">>>=";
			case SyntaxKind.GreaterThanToken:
				return ">";
			case SyntaxKind.QuestionToken:
				return "?";
			case SyntaxKind.TildeToken:
				return "~";
			case SyntaxKind.CaretToken:
				return "^";
			case SyntaxKind.CaretEqualsToken:
				return "^=";
			case SyntaxKind.AsteriskAsteriskToken:
				return "**";
			case SyntaxKind.CommaToken:
				return ",";
			case SyntaxKind.OpenBraceToken:
				return "{";
			case SyntaxKind.CloseBraceToken:
				return "}";
			case SyntaxKind.OpenParenToken:
				return "(";
			case SyntaxKind.CloseParenToken:
				return ")";
			case SyntaxKind.OpenBracketToken:
				return "[";
			case SyntaxKind.CloseBracketToken:
				return "]";
			case SyntaxKind.DotToken:
				return ".";
			case SyntaxKind.DotDotDotToken:
				return "...";
			default:
				throw new TypeError(`${this.serializeToken.name} could not serialize a token of kind ${SyntaxKind[<SyntaxKind>token]}`);
		}
	}

	/**
	 * Formats the typeArguments given to a CallExpression or a NewExpression and returns an ITypeable.
	 * @param {CallExpression|NewExpression} statement
	 * @returns {ITypeable}
	 */
	private formatTypeArguments(statement: CallExpression | NewExpression): ITypeable {
		const typeExpressions = statement.typeArguments == null ? null : statement.typeArguments.map(typeArg => this.getTypeExpression(typeArg));
		let typeExpression: TypeExpression = [];
		if (typeExpressions != null) {
			typeExpressions.forEach((typeExp, index) => {
				typeExp.forEach(part => typeExpression.push(part));
				if (index !== typeExpressions.length - 1) typeExpression.push(", ");
			});
		}
		const typeFlattened = typeExpression == null || typeExpression.length < 1 ? null : this.serializeTypeExpression(typeExpression);
		const typeBindings = typeExpression == null || typeExpression.length < 1 ? null : this.takeTypeBindings(typeExpression);

		return {
			expression: typeExpression.length < 1 ? null : typeExpression,
			flattened: typeFlattened,
			bindings: typeBindings
		};
	}

	/**
	 * Formats the callable identifier and property path (if any) of a given CallExpression or NewExpression and returns an ICallable.
	 * @param {CallExpression|NewExpression} statement
	 * @returns {ICallable}
	 */
	private formatCallable(statement: CallExpression | NewExpression): ICallable {
		const exp = statement.expression;
		let property: ArbitraryValue = null;
		let identifier: ArbitraryValue = null;
		
		if (this.isIdentifierObject(exp)) {
			identifier = this.getNameOfMember(exp, false, true);
		}

		if (this.isPropertyAccessExpression(exp)) {
			property = this.getNameOfMember(exp.expression);
			identifier = this.getNameOfMember(exp.name, false, true);
		}

		if (identifier == null) {
			throw new TypeError(`${this.formatCallable.name} could not format a CallExpression|NewExpression with an expression of kind ${SyntaxKind[exp.kind]}`);
		}
		return {
			property,
			identifier
		};
	}

	/**
	 * Formats a CallExpression into an ICallExpression.
	 * @param {CallExpression}
	 * @returns {ICallExpression}
	 */
	private formatCallExpression(statement: CallExpression): ICallExpression {
		
		return {
			...this.formatCallable(statement),
			arguments: {
				startsAt: statement.arguments.pos,
				endsAt: statement.arguments.end,
				argumentsList: this.formatArguments(statement)
			},
			type: this.formatTypeArguments(statement)
		};

	}

	/**
	 * Formats a NewExpression into an INewExpression.
	 * @param {NewExpression}
	 * @returns {INewExpression}
	 */
	private formatNewExpression(statement: NewExpression): INewExpression {
		
		return {
			...this.formatCallable(statement),			
			arguments: {
				startsAt: statement.arguments == null ? -1 : statement.arguments.pos,
				endsAt: statement.arguments == null ? -1 : statement.arguments.end,
				argumentsList: this.formatArguments(statement)
			},
			type: this.formatTypeArguments(statement)
		};

	}

	/**
	 *Formats the given Statement into an ICallExpression.
	 * @param {Statement|Expression} statement
	 * @returns {ICallExpression}
	 */
	private getCallExpression(statement: Statement|Expression): ICallExpression {
		if (this.isCallExpression(statement)) {
			return this.formatCallExpression(statement);
		}

		if (this.isExpressionStatement(statement)) {
			return this.getCallExpression(statement.expression);
		}
		throw new TypeError(`${this.getCallExpression.name} could not format a CallExpression of kind ${SyntaxKind[statement.kind]}`);
	}

	/**
	 *Formats the given Statement into an INewExpression.
	 * @param {Statement|Expression} statement
	 * @returns {INewExpression}
	 */
	private getNewExpression(statement: Statement|Expression): INewExpression {
		if (this.isNewExpression(statement)) {
			return this.formatNewExpression(statement);
		}
		throw new TypeError(`${this.getNewExpression.name} could not format a NewExpression of kind ${SyntaxKind[statement.kind]}`);
	}

	/**
	 * Gets and formats all CallExpressions associated with the given file.
	 * These hold information such as the arguments the members are invoked with, generic type
	 * arguments and such.
	 * @param {string} fileName
	 * @param {boolean} [deep=false]
	 * @returns {ICallExpression[]}
	 */	
	public getCallExpressionsForFile(fileName: string, deep: boolean = false): ICallExpression[] {
		const statements = this.getFile(fileName);
		if (statements == null) throw new ReferenceError(`${this.getCallExpressionsForFile.name} could not find any statements associated with the given filename: ${fileName}. Have you added it to the service yet?`);
		return this.getCallExpressions(statements, deep);
	}

	/**
	 * Gets and formats all CallExpressions associated with the given statements.
	 * These hold information such as the arguments the members are invoked with, generic type
	 * arguments and such.
	 * @param {Statement[]} statements
	 * @param {boolean} [deep=false]
	 * @returns {ICallExpression[]}
	 */
	public getCallExpressions (statements: Statement[], deep: boolean = false): ICallExpression[] {
		const expressions: ICallExpression[] = [];

		statements.forEach(statement => {
			if (this.isCallExpression(statement) || this.isExpressionStatement(statement)) {
				expressions.push(this.getCallExpression(statement));
			}

			if (deep) {
				const otherCallExpressions = this.getCallExpressions(this.findChildStatements(statement), deep);
				otherCallExpressions.forEach(exp => expressions.push(exp));
			}

		});
		return expressions;
	}

	/**
	 * Gets and formats all NewExpressions associated with the given file.
	 * These hold information such as the arguments the constructor is invoked with, generic type
	 * arguments and such.
	 * @param {string} fileName
	 * @param {boolean} [deep=false]
	 * @returns {INewExpression[]}
	 */
	public getNewExpressionsForFile(fileName: string, deep: boolean = false): INewExpression[] {
		const statements = this.getFile(fileName);
		if (statements == null) throw new ReferenceError(`${this.getNewExpressionsForFile.name} could not find any statements associated with the given filename: ${fileName}. Have you added it to the service yet?`);
		return this.getNewExpressions(statements, deep);
	}

	/**
	 * Gets and formats all NewExpressions associated with the given statements.
	 * These hold information such as the arguments the constructor is invoked with, generic type
	 * arguments and such.
	 * @param {Statement[]} statements
	 * @param {boolean} [deep=false]
	 * @returns {INewExpression[]}
	 */
	public getNewExpressions (statements: Statement[], deep: boolean = false): INewExpression[] {
		const expressions: INewExpression[] = [];

		statements.forEach(statement => {
			if (this.isExpressionStatement(statement) && this.isNewExpression(statement.expression)) {
				expressions.push(this.getNewExpression(statement.expression));
			}

			if (deep) {
				const otherNewExpressions = this.getNewExpressions(this.findChildStatements(statement), deep);
				otherNewExpressions.forEach(exp => expressions.push(exp));
			}

		});
		return expressions;
	}

	/**
	 * If given an ImportDeclaration, a formatted IModuleDependency will be returned holding the relative and full import-path
	 * as well as any bindings that will live in the local scope of the given file.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {IModuleDependency}
	 */
	private getImportDeclaration (statement: Statement | Declaration | Expression | Node): IModuleDependency {
		if (!this.isImportDeclaration(statement)) throw new Error(`Could not get an import declaration for statement that isn't an ImportDeclaration!`);
		const sourceFileProperties = this.getSourceFileProperties(statement);
		const filePath = sourceFileProperties.filePath;

		// TODO: Remove any declaration
		const relativePath = (<any>statement.moduleSpecifier).text;
		const fullPath = join(dirname(filePath), relativePath);
		const clause = statement.importClause;

		if (clause == null || clause.namedBindings == null) {
			// A path import, e.g: "import './foo.ts'".
			return {
				relativePath,
				fullPath,
				bindings: []
			};
		}

		return {
			relativePath,
			fullPath,
			bindings: this.isNamedImports(clause.namedBindings) ? clause.namedBindings.elements.map(binding => binding.name.text) : []
		};
	}

	/**
	 * Gets the member name for call expression.
	 * @param {CallExpression} statement
	 * @returns {string}
	 */
	private getCallExpressionMemberName (statement: CallExpression): string {
		if (this.isIdentifierObject(statement.expression)) return statement.expression.text;
		throw new TypeError(`${this.getCallExpressionMemberName.name} could not get the name for an expression!`);
	}

	/**
	 * Gets all variable assignments (if any) that occurs in the given file
	 * and returns them in a VariableIndexer. If 'deep' is true, it will walk through the Statements recursively.
	 * @param {string} fileName
	 * @param {boolean} [deep=false]
	 * @returns {VariableIndexer}
	 */	
	public getVariableAssignmentsForFile(fileName: string, deep: boolean = false): VariableIndexer {
		const statements = this.getFile(fileName);
		if (statements == null) throw new ReferenceError(`${this.getVariableAssignmentsForFile.name} could not find any statements associated with the given filename: ${fileName}. Have you added it to the service yet?`);
		return this.getVariableAssignments(statements, deep);
	}

	/**
	 * Gets all variable assignments (if any) that occurs in the given array of statements
	 * and returns them in a VariableIndexer. If 'deep' is true, it will walk through the Statements recursively.
	 * @param {Statement[]} statements
	 * @param {boolean} [deep=false]
	 * @returns {VariableIndexer}
	 */
	public getVariableAssignments (statements: Statement[], deep: boolean = false): VariableIndexer {
		const assignmentMap: VariableIndexer = {};

		for (const statement of statements) {
			if (this.isVariableStatement(statement)) {
				const declarations = statement.declarationList.declarations;
				declarations.forEach(declaration => {

					if (this.isIdentifierObject(declaration.name)) {
						const name = declaration.name.text;
						const valueExpression = declaration.initializer == null ? null : this.getValueExpression(declaration.initializer);
						const startsAt = declaration.pos;
						const endsAt = declaration.end;
						const typeExpression = declaration.type == null ? null : this.getTypeExpression(declaration.type);
						const typeFlattened = typeExpression == null ? null : this.serializeTypeExpression(typeExpression);
						const typeBindings = typeExpression == null ? null : this.takeTypeBindings(typeExpression);

						assignmentMap[name] = {
							name,
							value: {
								expression: valueExpression,
								// TODO: Compute this!
								resolved: ""
							},
							startsAt,
							endsAt,
							type: {
								expression: typeExpression,
								flattened: typeFlattened,
								bindings: typeBindings
							}
						};
					}
				});
			}

			if (deep) {
				const otherAssignments = this.getVariableAssignments(this.findChildStatements(statement), deep);
				Object.keys(otherAssignments).forEach(key => {
					// Only assign the deep variable to the assignmentMap if there isn't a match in the scope above it.
					if (assignmentMap[key] == null) Object.assign(assignmentMap, { [key]: otherAssignments[key] });
				});
			}

		}		
		return assignmentMap;
	}

	/**
	 * Finds all "children" of the given statement, if it has any.
	 * @param {Statement|Expression} statement
	 * @returns {Statement[]}
	 */
	private findChildStatements (statement: Statement|Expression|Declaration|Node): Statement[] {

		if (this.isIfStatement(statement)) {
			return this.findChildStatements(statement.thenStatement);
		}

		if (this.isShorthandPropertyAssignment(statement)) {
			return statement.objectAssignmentInitializer == null ? [] : this.findChildStatements(statement.objectAssignmentInitializer);
		}

		if (this.isDefaultClause(statement) || this.isCaseClause(statement)) {
			const statements: Statement[] = [];

			statement.statements.forEach(child => {
				this.findChildStatements(child).forEach(childStatement => statements.push(childStatement));
			});

			return statements;
		}

		if (this.isWhileStatement(statement)) {
			return this.findChildStatements(statement.statement);
		}

		if (this.isParenthesizedExpression(statement)) {
			return this.findChildStatements(statement.expression);
		}

		if (this.isCaseBlock(statement)) {
			const statements: Statement[] = [];

			statement.clauses.forEach(clause => {
				this.findChildStatements(clause).forEach(childStatement => statements.push(childStatement));
			});

			return statements;
		}

		if (this.isAwaitExpression(statement)) {
			return this.findChildStatements(statement.expression);
		}

		if (this.isSwitchStatement(statement)) {
			return this.findChildStatements(statement.caseBlock);
		}

		if (this.isBlockDeclaration(statement)) {
			return statement.statements;
		}

		if (this.isReturnStatement(statement)) {
			return statement.expression == null ? [] : this.findChildStatements(statement.expression);
		}

		if (this.isArrowFunction(statement)) {
			return this.findChildStatements(statement.body);
		}

		if (this.isLabeledStatement(statement)) {
			return this.findChildStatements(statement.statement);
		}

		if (this.isConditionalExpression(statement)) {
			const whenTrue = this.findChildStatements(statement.whenTrue);
			const whenFalse = this.findChildStatements(statement.whenFalse);
			return [...whenTrue, ...whenFalse];
		}

		if (this.isBinaryExpression(statement)) {
			const left = this.findChildStatements(statement.left);
			const right = this.findChildStatements(statement.right);
			return [...left, ...right];	
		}

		if (this.isFunctionDeclaration(statement)) {
			return statement.body == null ? [] : this.findChildStatements(statement.body);
		}

		if (this.isExpressionStatement(statement)) {
			return this.findChildStatements(statement.expression);
		}

		if (this.isTryStatement(statement)) {
			const tryBlock = this.findChildStatements(statement.tryBlock);
			const catchClause = statement.catchClause == null ? [] : this.findChildStatements(statement.catchClause.block);
			const finallyBlock = statement.finallyBlock == null ? [] : this.findChildStatements(statement.finallyBlock);

			return [...tryBlock, ...catchClause, ...finallyBlock];
		}

		if (this.isSpreadAssignment(statement) || this.isSpreadElement(statement)) {
			return this.findChildStatements(statement.expression);
		}

		if (this.isVariableStatement(statement)) {
			const statements: Statement[] = [];

			statement.declarationList.declarations.forEach(declaration => {
				this.findChildStatements(declaration).forEach(childStatement => statements.push(childStatement));
			});
			return statements;
		}

		if (this.isVariableDeclaration(statement)) {
			return statement.initializer == null ? [] : this.findChildStatements(statement.initializer);
		}

		if (this.isElementAccessExpression(statement)) {
			return this.findChildStatements(statement.expression);
		}

		if (this.isPropertyAccessExpression(statement)) {
			return this.findChildStatements(statement.expression);
		}

		if (this.isPrefixUnaryExpression(statement)) {
			return this.findChildStatements(statement.operand);
		}

		if (this.isPostfixUnaryExpression(statement)) {
			return this.findChildStatements(statement.operand);
		}

		if (this.isFunctionExpression(statement)) {
			return this.findChildStatements(statement.body);
		}

		if (this.isTypeOfExpression(statement)) {
			return this.findChildStatements(statement.expression);
		}

		if (this.isMethodDeclaration(statement)) {
			return statement.body == null ? [] : this.findChildStatements(statement.body);
		}

		if (this.isTemplateExpression(statement)) {
			const statements: Statement[] = [];

			statement.templateSpans.forEach(span => {
				this.findChildStatements(span.expression).forEach(childStatement => statements.push(childStatement));
			});

			return statements;
		}

		if (this.isObjectLiteralExpression(statement)) {
			const statements: Statement[] = [];

			statement.properties.forEach(property => {
				this.findChildStatements(property).forEach(childStatement => statements.push(childStatement));
			});

			return statements;
		}

		if (this.isPropertyAssignment(statement)) {
			return this.findChildStatements(statement.initializer);
		}

		if (this.isConstructorDeclaration(statement)) {
			return statement.body == null ? [] : this.findChildStatements(statement.body);
		}

		if (this.isArrayLiteralExpression(statement)) {
			const statements: Statement[] = [];

			statement.elements.forEach(element => {
				this.findChildStatements(element).forEach(childStatement => statements.push(childStatement));
			});

			return statements;
		}

		if (this.isPropertyDeclaration(statement)) {
			return statement.initializer == null ? [] : this.findChildStatements(statement.initializer);
		}

		if (this.isClassExpression(statement) || this.isClassDeclaration(statement)) {
			const statements: Statement[] = [];

			statement.members.forEach(member => {
				this.findChildStatements(member).forEach(childStatement => statements.push(childStatement));
			});

			return statements;
		}

		if (this.isForStatement(statement)) {
			return this.findChildStatements(statement.statement);
		}

		if (this.isForInStatement(statement)) {
			return this.findChildStatements(statement.statement);
		}

		if (this.isForOfStatement(statement)) {
			return this.findChildStatements(statement.statement);
		}

		if (this.isTypeAssertionExpression(statement)) {
			return this.findChildStatements(statement.expression);
		}

		if (this.isDoStatement(statement)) {
			return this.findChildStatements(statement.expression);
		}

		if (this.isImportDeclaration(statement)) {
			return [];
		}

		if (this.isEmptyStatement(statement)) {
			return [];
		}

		if (this.isDeleteExpression(statement)) {
			return [];
		}

		if (this.isThisKeyword(statement)) {
			return [];
		}

		if (this.isBreakStatement(statement)) {
			return [];
		}

		if (this.isThrowStatement(statement)) {
			return [];
		}

		if (this.isContinueStatement(statement)) {
			return [];
		}

		if (this.isNewExpression(statement)) {
			return [];
		}

		if (this.isNullKeyword(statement)) {
			return [];
		}

		if (this.isUndefinedKeyword(statement)) {
			return [];
		}

		if (this.isIdentifierObject(statement)) {
			return [];
		}

		if (this.isCallExpression(statement)) {
			return [];
		}

		if (this.isRegularExpressionLiteral(statement)) {
			return [];
		}

		if (this.isStringLiteral(statement)) {
			return [];
		}

		if (this.isNumericLiteral(statement)) {
			return [];
		}

		if (this.isFirstLiteralToken(statement)) {
			return [];
		}

		if (this.isTrueKeyword(statement)) {
			return [];
		}

		if (this.isFalseKeyword(statement)) {
			return [];
		}

		if (this.isLiteralToken(statement)) {
			return [];
		}

		if (this.isTemplateToken(statement)) {
			return [];
		}

		throw new TypeError(`${this.findChildStatements.name} could not find child statements for a statement of kind ${SyntaxKind[statement.kind]} around here: ${this.getSourceFileProperties(statement).fileContents.slice(statement.pos, statement.end)}`);
		// return [];
	}

	/**
	 * Gets all class declarations (if any) that occurs in the given file
	 * and returns them as a ClassIndexer.
	 * @param {Statement[]} statements
	 * @param {boolean} [deep=false]
	 * @returns {ClassIndexer}
	 */	
	public getClassDeclarationsForFile(fileName: string, deep: boolean = false): ClassIndexer {
		const statements = this.getFile(fileName);
		if (statements == null) throw new ReferenceError(`${this.getClassDeclarationsForFile.name} could not find any statements associated with the given filename: ${fileName}. Have you added it to the service yet?`);
		return this.getClassDeclarations(statements, deep);
	}

	/**
	 * Gets all class declarations (if any) that occurs in the given array of statements
	 * and returns them as a ClassIndexer.
	 * @param {Statement[]} statements
	 * @param {boolean} [deep=false]
	 * @returns {ClassIndexer}
	 */
	public getClassDeclarations (statements: Statement[], deep: boolean = false): ClassIndexer {
		const declarations: ClassIndexer = {};
		for (const statement of statements) {
			const declaration = this.isClassDeclaration(statement) ? this.getClassDeclaration(statement) : null;
			if (declaration != null) {
				declarations[declaration.name] = declaration;
			}
			if (deep) {
				const otherDeclarations = this.getClassDeclarations(this.findChildStatements(statement), deep);
				Object.keys(otherDeclarations).forEach(key => {
					// Only assign the deep class to the declarations if there isn't a match in the scope above it.
					if (declarations[key] == null) Object.assign(declarations, { [key]: otherDeclarations[key] });
				});
			}
		}
		return declarations;
	}

	/**
	 * Gets and returns all ImportDeclarations (if any) that occur in the given file
	 * @param {string} fileName
	 * @returns {IModuleDependency[]}
	 */
	public getImportDeclarationsForFile(fileName: string): IModuleDependency[] {
		const statements = this.getFile(fileName);
		if (statements == null) throw new ReferenceError(`${this.getImportDeclarationsForFile.name} could not find any statements associated with the given filename: ${fileName}. Have you added it to the service yet?`);
		return this.getImportDeclarations(statements);
	}

	/**
	 * Gets and returns all ImportDeclarations (if any) that occur in the given array of statements.
	 * @param {Statement[]} statements
	 * @returns {IModuleDependency[]}
	 */
	public getImportDeclarations (statements: Statement[]): IModuleDependency[] {
		const declarations: IModuleDependency[] = [];
		for (const statement of statements) {
			if (this.isImportDeclaration(statement)) {
				const declaration = this.getImportDeclaration(statement);
				declarations.push(declaration);
			}
		}
		return declarations;
	}

	/**
	 * Gets all ExportDeclarations (if any) that occur in the given file and returns a Set
	 * of all the identifiers that are being exported.
	 * @param {string} fileName
	 * @returns {Set<string>}
	 */	
	public getExportDeclarationsForFile(fileName: string): Set<string> {
		const statements = this.getFile(fileName);
		if (statements == null) throw new ReferenceError(`${this.getExportDeclarationsForFile.name} could not find any statements associated with the given filename: ${fileName}. Have you added it to the service yet?`);
		return this.getExportDeclarations(statements);
	}

	/**
	 * Gets all ExportDeclarations (if any) that occur in the given array of statements and returns a Set
	 * of all the identifiers that are being exported.
	 * @param {Statement[]} statements
	 * @returns {Set<string>}
	 */
	public getExportDeclarations (statements: Statement[]): Set<string> {
		const declarations: Set<string> = new Set();
		for (const statement of statements) {
			if (this.isExportDeclaration(statement)) {
				if (statement.exportClause != null) {
					statement.exportClause.elements.forEach(element => declarations.add(element.name.text));
				}
			}
		}
		return declarations;
	}


	/**
	 * Checks and formats the initialization value of the given statement (if any) and returns it.
	 * Since such a statement can be a combination of multiple operations and identifiers, an array of statements will be
	 * returned.
	 * @param {Statement|Expression|Node} rawStatement
	 * @returns {NullableInitializationValue}
	 */
	public getValueExpression(rawStatement: Statement | Expression | Node): InitializationValue {

		if (this.isNumericLiteral(rawStatement)) {
			const marshalled = this.marshaller.marshal<string, number>(rawStatement.text);
			return [marshalled];
		}

		if (this.isStringLiteral(rawStatement)) {
			return [rawStatement.text];
		}

		if (this.isRegularExpressionLiteral(rawStatement)) {
			const marshalled = this.marshaller.marshal<string, RegExpConstructor>(rawStatement.text, RegExp);
			return [marshalled];
		}

		if (this.isNoSubstitutionTemplateLiteral(rawStatement)) {
			const marshalled = this.marshaller.marshal<string, string>(rawStatement.text);
			return [marshalled];
		}

		if (this.isTemplateHead(rawStatement) || this.isTemplateMiddle(rawStatement) || this.isTemplateTail(rawStatement)) {
			const marshalled = this.marshaller.marshal<string, string>(rawStatement.text, "");
			return [marshalled];
		}

		if (this.isTypeAssertionExpression(rawStatement)) {
			return this.getValueExpression(rawStatement.expression);
		}

		if (this.isAwaitExpression(rawStatement)) {
			return ["await", " ", ...this.getValueExpression(rawStatement.expression)];
		}

		if (this.isTemplateSpan(rawStatement)) {
			const head = this.getValueExpression(rawStatement.expression);
			const tail = this.getValueExpression(rawStatement.literal);
			const headNormalized: InitializationValue = [];
			head.forEach(part => {
				if (part instanceof BindingIdentifier) {
					headNormalized.push("${");
					headNormalized.push(part);
					headNormalized.push("}");
				}
				else headNormalized.push(part);
			});

			return [...headNormalized, ...tail];
		}

		if (this.isCatchClause(rawStatement)) {
			return ["catch", "(", ...this.getValueExpression(rawStatement.variableDeclaration), ")", "{", ...this.getValueExpression(rawStatement.block), "}"];
		}

		if (this.isExpressionStatement(rawStatement)) {
			return this.getValueExpression(rawStatement.expression);
		}

		if (this.isTryStatement(rawStatement)) {
			let arr: InitializationValue = ["try", "{", ...this.getValueExpression(rawStatement.tryBlock), "}"];
			if (rawStatement.catchClause != null ) arr = [...arr, ...this.getValueExpression(rawStatement.catchClause)];
			if (rawStatement.finallyBlock != null) arr = [...arr, "finally", "{", ...this.getValueExpression(rawStatement.finallyBlock), "}"];
			return arr;
		}

		if (this.isTypeOfExpression(rawStatement)) {
			return ["typeof", " ", ...this.getValueExpression(rawStatement.expression)];
		}

		if (this.isPrefixUnaryExpression(rawStatement)) {
			return [this.serializeToken(rawStatement.operator), ...this.getValueExpression(rawStatement.operand)];
		}

		if (this.isPostfixUnaryExpression(rawStatement)) {
			return [...this.getValueExpression(rawStatement.operand), this.serializeToken(rawStatement.operator)];
		}

		if (this.isDeleteExpression(rawStatement)) {
			return [this.marshalToken(rawStatement.kind), " ", ...this.getValueExpression(rawStatement.expression)];
		}

		if (this.isEmptyStatement(rawStatement)) {
			return [];
		}

		if (this.isVariableDeclarationList(rawStatement)) {
			const keyword = this.serializeFlag(rawStatement.flags) || "var";
			const values: InitializationValue = [keyword, " "];
			
			rawStatement.declarations.forEach((declaration, index) => {
				const content = this.getValueExpression(declaration);
				// Remove empty strings from the contents and add everything else to the value array.
				content.forEach(part => values.push(part));
				if (index !== rawStatement.declarations.length - 1) values.push(",");
			});

			return values;
		}

		if (this.isIfStatement(rawStatement)) {
			const arr: InitializationValue = ["if", "(", ...this.getValueExpression(rawStatement.expression), ")", "{", ...this.getValueExpression(rawStatement.thenStatement), "}"];
			return arr;
		}

		if (this.isForOfStatement(rawStatement)) {
			const arr: InitializationValue = [
				"for",
				...(rawStatement.awaitModifier == null ? [] : [" ", ...this.getValueExpression(rawStatement.awaitModifier)]),
				"(",
				...(rawStatement.initializer == null ? [] : this.getValueExpression(rawStatement.initializer)), " ", "of", " ",
				...this.getValueExpression(rawStatement.expression),
				")", "{",
				...this.getValueExpression(rawStatement.statement),
				"}"
			];
			return arr;
		}

		if (this.isForInStatement(rawStatement)) {
			const arr: InitializationValue = [
				"for", "(",
				...(rawStatement.initializer == null ? [] : this.getValueExpression(rawStatement.initializer)), " ", "in", " ",
				...this.getValueExpression(rawStatement.expression), ")", "{",
				...this.getValueExpression(rawStatement.statement),
				"}"
			];
			return arr;
		}

		if (this.isForStatement(rawStatement)) {
			const arr: InitializationValue = [
				"for", "(",
				...(rawStatement.initializer == null ? [] : this.getValueExpression(rawStatement.initializer)), ";",
				...(rawStatement.condition == null ? [] : this.getValueExpression(rawStatement.condition)), ";",
				...(rawStatement.incrementor == null ? [] : this.getValueExpression(rawStatement.incrementor)), ")", "{",
				...this.getValueExpression(rawStatement.statement),
				"}"
			];
			return arr;
		}

		if (this.isThrowStatement(rawStatement)) {
			return [this.marshalToken(rawStatement.kind), " ", ...this.getValueExpression(rawStatement.expression)];
		}

		if (this.isBreakStatement(rawStatement)) {
			return [this.marshalToken(rawStatement.kind)];
		}

		if (this.isContinueStatement(rawStatement)) {
			return [this.marshalToken(rawStatement.kind)];
		}

		if (this.isDoStatement(rawStatement)) {
			return [this.marshalToken(rawStatement.kind), "{", ...this.getValueExpression(rawStatement.expression), "}"];
		}

		if (this.isDefaultClause(rawStatement)) {
			const arr: InitializationValue = ["default", ":", "{"];
			rawStatement.statements.forEach(statement => {
				const value = this.getValueExpression(statement);
				value.forEach(part => arr.push(part));
			});
			arr.push("}");
			return arr;
		}

		if (this.isWhileStatement(rawStatement)) {
			return ["while", "(", ...this.getValueExpression(rawStatement.expression), ")", "{", ...this.getValueExpression(rawStatement.statement), "}"];
		}

		if (this.isCaseClause(rawStatement)) {
			const arr: InitializationValue = ["case", " ", ...this.getValueExpression(rawStatement.expression), ":", "{"];
			rawStatement.statements.forEach(statement => {
				const value = this.getValueExpression(statement);
				value.forEach(part => arr.push(part));
			});
			arr.push("}");
			return arr;
		}

		if (this.isCaseBlock(rawStatement)) {
			const arr: InitializationValue = [];
			rawStatement.clauses.forEach(block => {
				const value = this.getValueExpression(block);
				value.forEach(part => arr.push(part));
			});
			return arr;
		}

		if (this.isSwitchStatement(rawStatement)) {
			return ["switch", "(", ...this.getValueExpression(rawStatement.expression), ")", "{", ...this.getValueExpression(rawStatement.caseBlock), "}"];
		}

		if (this.isBinaryExpression(rawStatement)) {
			const arr: InitializationValue = [];

			const left = this.getValueExpression(rawStatement.left);
			const operator = this.getValueExpression(rawStatement.operatorToken);
			const right = this.getValueExpression(rawStatement.right);

			left.forEach(item => arr.push(item));
			operator.forEach(item => arr.push(item));
			right.forEach(item => arr.push(item));
			return arr;
		}

		if (this.isConditionalExpression(rawStatement)) {
			const arr: InitializationValue = [];
			const condition = this.getValueExpression(rawStatement.condition);
			const question = this.getValueExpression(rawStatement.questionToken);
			const colon = this.getValueExpression(rawStatement.colonToken);
			const whenTrue = this.getValueExpression(rawStatement.whenTrue);
			const whenFalse = this.getValueExpression(rawStatement.whenFalse);

			condition.forEach(item => arr.push(item));
			question.forEach(item => arr.push(item));
			whenTrue.forEach(item => arr.push(item));
			colon.forEach(item => arr.push(item));
			whenFalse.forEach(item => arr.push(item));
			return arr;
		}

		if (this.isCallExpression(rawStatement) || this.isNewExpression(rawStatement)) {
			const left = this.getValueExpression(rawStatement.expression);
			const arr: InitializationValue = [];
			if (this.isNewExpression(rawStatement)) {
				arr.push("new");
				arr.push(" ");
			}
			left.forEach(part => arr.push(part));
			arr.push("(");
			const args = rawStatement.arguments;
			if (args != null) args.forEach((arg, index) => {
				const value = this.getValueExpression(arg);
				value.forEach(item => {
					arr.push(item);
					if (index !== args.length - 1) arr.push(",");
				});
			});
			arr.push(")");
			return arr;
		}

		if (this.isObjectLiteralExpression(rawStatement)) {
			const obj: InitializationValue = ["{"];
			rawStatement.properties.forEach((property, index) => {

				if (this.isSpreadAssignment(property)) {
					obj.push("...");
					const exp = this.getValueExpression(property.expression);
					exp.forEach(item => obj.push(item));
				} else {

					if (this.isPropertyAssignment(property)) {
						if (property.name == null) return;

						// Check if the property name is computed (.eg. [key]: "foo").
						if (this.isComputedPropertyName(property.name)) obj.push("[");

						// Check if the property name is computed and a call expression (.eg. [getKey()]: "foo").
						if (this.isComputedPropertyName(property.name) && this.isCallExpression(property.name.expression)) {
							const callExpression = this.getValueExpression(property.name.expression);
							callExpression.forEach(item => obj.push(item));
						} else {
							// Otherwise, just push the name of it.
							obj.push(this.getNameOfMember(property.name, true, true));
						}

						if (this.isComputedPropertyName(property.name)) obj.push("]");

						obj.push(":");
						const value = this.getValueExpression(property.initializer);
						value.forEach(item => obj.push(item));
					}

					else if (this.isMethodDeclaration(property)) {
						const value = this.getValueExpression(property);
						value.forEach(item => obj.push(item));
					}

				}
				if (index !== rawStatement.properties.length - 1) obj.push(",");
			});
			obj.push("}");
			return obj;
		}

		if (this.isArrayLiteralExpression(rawStatement)) {
			const arr: InitializationValue = ["["];
			rawStatement.elements.forEach((element, index) => {
				const value = this.getValueExpression(element);
				value.forEach(part => arr.push(part));
				const lastPart = value[value.length - 1];
				if (index !== rawStatement.elements.length - 1 && lastPart !== "...") arr.push(",");
			});

			arr.push("]");
			return arr;
		}

		if (this.isTemplateExpression(rawStatement)) {

			let values: InitializationValue = [...this.getValueExpression(rawStatement.head)];

			rawStatement.templateSpans.forEach(span => {
				const content = this.getValueExpression(span);
				// Remove empty strings from the contents and add everything else to the value array.
				content.filter(item => !(typeof item === "string" && item.length < 1)).forEach(checkedItem => values.push(checkedItem));
			});


			return ["\`", ...values, "\`"];
		}

		if (this.isPropertyAccessExpression(rawStatement) || this.isElementAccessExpression(rawStatement)) {
			const arr: InitializationValue = [];
			const left = this.getValueExpression(rawStatement.expression);
			const right = this.isPropertyAccessExpression(rawStatement) 
				? this.getValueExpression(rawStatement.name)
				: rawStatement.argumentExpression == null ? [] : ["[", ...this.getValueExpression(rawStatement.argumentExpression), "]"];
			
			const lastLeft = left[left.length - 1];
			const firstRight = right[0];
			if (this.shouldBeIndexedLookup(lastLeft, firstRight)) {
				right.splice(0, 1, firstRight == null ? "" : firstRight.toString());
			}

			if (this.isPropertyAccessExpression(rawStatement)) {
				right.forEach((part) => {
				if (!(part instanceof BindingIdentifier)) {
					arr.push(this.convertToIndexedLookup(part))
				} else {
					arr.push(part);
				}
			});

			return [...left, ...arr];
			}
			
			return [...left, ...right];
			
		}

		if (this.isConstructorDeclaration(rawStatement)) {
			const arr: InitializationValue = ["constructor"];
			arr.push("(");
			const args = rawStatement.parameters;
			if (args != null) args.forEach((arg, index) => {
				const value = this.getValueExpression(arg);
				value.forEach(item => {
					arr.push(item);
					if (index !== args.length - 1) arr.push(",");
				});
			});
			arr.push(")");
			arr.push("{");
			const body = rawStatement.body == null ? [] : this.getValueExpression(rawStatement.body);
			body.forEach(part => arr.push(part));
			arr.push("}");
			return arr;
		}

		if (this.isClassExpression(rawStatement)) {
			const name = rawStatement.name == null ? [] : [this.getNameOfMember(rawStatement.name, false, true)];
			const heritage = rawStatement.heritageClauses == null ? null : this.formatHeritageClauses(rawStatement.heritageClauses).extendsClass;
			const heritageFormatted = heritage == null ? [] : [" ", "extends", " ", heritage];
			const members: InitializationValue = ["{"];
			
			rawStatement.members.forEach(member => {
				const content = this.getValueExpression(member);
				// Remove empty strings from the contents and add everything else to the value array.
				content.forEach(part => members.push(part));
			});
			members.push("}");

			return ["class", " ", ...name, ...heritageFormatted,  ...members];
		}

		if (this.isVariableDeclaration(rawStatement)) {
			
			const name = this.getNameOfMember(rawStatement.name, false, true);
			const type = rawStatement.type == null ? [] : [":", ...this.getTypeExpression(rawStatement.type)];
			const initializer = rawStatement.initializer == null ? [] : ["=", ...this.getValueExpression(rawStatement.initializer)];
			return [name, ...type, ...initializer];
		}

		if (this.isVariableStatement(rawStatement)) {
			return this.getValueExpression(rawStatement.declarationList);
		}

		if (this.isParameterDeclaration(rawStatement)) {
			const name = this.getNameOfMember(rawStatement.name);
			const initializer = rawStatement.initializer == null ? null : this.getValueExpression(rawStatement.initializer);
			const arr: InitializationValue = [name];
			if (initializer != null) {
				arr.push("=");
				initializer.forEach(item => arr.push(item));
			}
			return arr;
		}

		if (this.isArrowFunction(rawStatement)) {
			const arr: InitializationValue = ["("];
			const equalsGreaterThanToken = this.getValueExpression(rawStatement.equalsGreaterThanToken);
			const body = this.getValueExpression(rawStatement.body);

			rawStatement.parameters.forEach((parameter, index) => {
				const value = this.getValueExpression(parameter);
				value.forEach(item => arr.push(item));
				if (index !== rawStatement.parameters.length - 1) arr.push(",");
			});

			arr.push(")");
			equalsGreaterThanToken.forEach(item => arr.push(item));

			if (this.isBlockDeclaration(rawStatement.body)) {
				arr.push("{");
				body.forEach(item => arr.push(item));
				arr.push("}");
			} 
			else {
				body.forEach(item => arr.push(item));
			}

			return arr;
		}

		if (this.isFunctionExpression(rawStatement) || this.isMethodDeclaration(rawStatement)) {
			const arr: InitializationValue = this.isFunctionExpression(rawStatement) ? ["function", " "] : [];
			const body = rawStatement.body == null ? null : this.getValueExpression(rawStatement.body);

			if (rawStatement.name != null) {
				arr.push(this.getNameOfMember(rawStatement.name));
			}

			arr.push("(");

			rawStatement.parameters.forEach((parameter, index) => {
				const value = this.getValueExpression(parameter);
				value.forEach(item => arr.push(item));
				if (index !== rawStatement.parameters.length - 1) arr.push(",");
			});
			arr.push(")");
			arr.push("{");
			if (body != null) body.forEach(item => arr.push(item));
			arr.push("}");
			return arr;
		}

		if (this.isBlockDeclaration(rawStatement)) {
			const arr: InitializationValue = [];
			rawStatement.statements.forEach(statement => {
				const value = this.getValueExpression(statement);
				value.forEach(item => arr.push(item));
			});
			return arr;
		}

		if (this.isSpreadElement(rawStatement)) {
			return ["...", ...this.getValueExpression(rawStatement.expression)];
		}

		if (this.isParenthesizedExpression(rawStatement)) {
			return ["(", ...this.getValueExpression(rawStatement.expression), ")"];
		}

		if (this.isReturnStatement(rawStatement)) {
			return [this.marshalToken(rawStatement.kind), " ", ...(rawStatement.expression == null ? [] : this.getValueExpression(rawStatement.expression))];
		}

		if (this.isTokenObject(rawStatement)) {
			return [this.marshalToken(rawStatement.kind)];
		}

		if (this.isIdentifierObject(rawStatement)) {
			return [this.getNameOfMember(rawStatement, true)];
		}

		throw new TypeError(`${this.getValueExpression.name} could not extract a value for a statement of kind ${(<Identifier>rawStatement).kind == null ? "unknown" : SyntaxKind[(<Identifier>rawStatement).kind]} around here: ${this.getSourceFileProperties(rawStatement).fileContents.slice((<Identifier>rawStatement).pos, (<Identifier>rawStatement).end)}`);
	}

	/**
	 * Computes the mot probable native type of the given string.
	 * @param {string} text
	 * @returns {string}
	 */
	private mostProbableTypeOf (text: string): string {
		return typeof this.marshaller.marshal<string, ArbitraryValue>(text);
	}

	/**
	 * Returns the path of an expression.
	 * @param {ElementAccessExpression|Identifier|Expression}
	 * @returns {ArbitraryValue[]}
	 */
	private getPathOfExpression(expression: ElementAccessExpression | Identifier | Expression | BinaryExpression): ArbitraryValue[] {
		if (this.isBinaryExpression(expression)) {
			return [...this.getPathOfExpression(expression.left), this.serializeToken(expression.operatorToken.kind), ...this.getPathOfExpression(expression.right)];
		}

		return [this.getNameOfMember(expression, true, true)];
	}

	/**
	 * Returns true if the name of an identifier cannot be computed or refer to another identifier.
	 * @param {Statement} statement
	 * @returns {boolean}
	 */
	private memberHasNoBindingIdentifier(statement: Statement | Identifier): boolean {
		const parent = statement.parent;
		if (parent == null) return false;


		// If this is an identifier and the parent is a property access expression on a
		// parenthesized, array or object literal expression (e.g. (something || []).concat(otherThing)),
		// The right-hand side property access should never be attached to a BindingIdentifier.
		if (
			this.isIdentifierObject(statement) &&
			this.isPropertyAccessExpression(parent) &&
			(
				this.isCallExpression(parent.expression) ||
				this.isParenthesizedExpression(parent.expression) ||
				this.isStringLiteral(parent.expression) ||
				this.isNumericLiteral(parent.expression) ||
				this.isTemplateExpression(parent.expression) ||
				this.isTemplateHead(parent.expression) ||
				this.isTemplateMiddle(parent.expression) ||
				this.isTemplateTail(parent.expression) ||
				this.isArrayLiteralExpression(parent.expression) ||
				this.isObjectLiteralExpression(parent.expression) ||
				this.isPropertyAccessExpression(parent.expression)
			)
		) return true;

		// If this is the name of a method, function or parameter, it cannot be a BindingIdentifier.
		if (
			this.isIdentifierObject(statement) &&
			(
				this.isMethodDeclaration(parent) ||
				this.isFunctionDeclaration(parent) ||
				this.isFunctionExpression(parent) ||
				this.isParameterDeclaration(parent)
			)
		) return true;
		
		return false;

		// return statement.parent != null && (
		//	this.isPropertyAccessExpression(statement.parent) ||
		//	this.isPropertyAssignment(statement.parent) ||
		//	this.isParameterDeclaration(statement.parent) ||
		//	this.isMethodDeclaration(statement.parent) ||
		//	this.isFunctionDeclaration(statement.parent) ||
		//	this.isFunctionExpression(statement.parent)
		// );
	}

	/**
	 * Detects the name/key of a member of something (for example, an ObjectLiteral). If the second argument is truthy,
	 * the name may also be a non-string entity.
	 * @param {DeclarationName} name
	 * @param {boolean} [allowNonStringNames=false]
	 * @param {boolean} [forceNoBindingIdentifier=false]
	 * @returns {ArbitraryValue}
	 */
	private getNameOfMember(name: DeclarationName | Expression, allowNonStringNames: boolean = false, forceNoBindingIdentifier: boolean = false): ArbitraryValue {

		if (this.isComputedPropertyName(name)) {
			if (this.isPropertyName(name.expression)) {
				if (this.isComputedPropertyName(name.expression)) return this.getNameOfMember(name.expression, allowNonStringNames, false);
				return this.getNameOfMember(name.expression, allowNonStringNames, false);
			}

			if (this.isCallExpression(name.expression)) {
				return this.getNameOfMember(name.expression.expression, allowNonStringNames, forceNoBindingIdentifier);
			}

			throw new TypeError(`${this.getNameOfMember.name} could not compute the name of a ${SyntaxKind[name.kind]}: It wasn't a PropertyName or a CallExpression. Instead, it was a ${SyntaxKind[name.expression.kind]}`);
		}

		if (this.isIdentifierObject(name)) {
			const marshalled = this.marshaller.marshal<string, ArbitraryValue>(name.text, allowNonStringNames ? undefined : "");

			if (this.memberHasNoBindingIdentifier(name)) {
				// Then this is the key of a property-assignment. We already know it isn't computed, so it can't be an identifier to another variable.
				return marshalled;
			}

			// Otherwise, it most likely is a reference to a variable or other Identifier unless it is a global symbol like "Infinity" or "Nan".
			if (this.mostProbableTypeOf(name.text) === "string" && !forceNoBindingIdentifier) {
				return new BindingIdentifier(name.text);
			}
			return marshalled;
		}

		if (this.isFirstLiteralToken(name)) {
			return this.marshaller.marshal<string, ArbitraryValue>(name.text, allowNonStringNames ? undefined : "");
		}

		if (this.isStringLiteral(name)) {
			return name.text;
		}

		if (this.isThisKeyword(name)) {
			return new BindingIdentifier("this");
		}

		if (this.isRegularExpressionLiteral(name)) {
			return this.marshaller.marshal<string, RegExpConstructor>(name.text, RegExp);
		}

		if (this.isPropertyAccessExpression(name)) {
			const baseName = <string>this.getNameOfMember(name.expression, false, false);
			
			return new BindingIdentifier(baseName.toString());
		}

		if (this.isCallExpression(name)) {
			return this.getNameOfMember(name.expression, allowNonStringNames, forceNoBindingIdentifier);
		}

		if (this.isParenthesizedExpression(name)) {
			return this.getNameOfMember(name.expression, allowNonStringNames, forceNoBindingIdentifier);
		}

		if (this.isFunctionExpression(name)) {
			return name.name == null ? null : this.getNameOfMember(name.name, allowNonStringNames, forceNoBindingIdentifier);
		}

		if (this.isElementAccessExpression(name)) {
			const baseName = <string>this.getNameOfMember(name.expression, false, false);
			
			return new BindingIdentifier(baseName.toString());
		}
	
		throw new TypeError(`${this.getNameOfMember.name} could not compute the name of a ${SyntaxKind[name.kind]} around here: ${this.getSourceFileProperties(name).fileContents.slice(name.pos, name.end)}.`);
	}

	/**
	 * Tokenizes the type information from the given statement and returns a TypeExpression.
	 * @param {ParameterDeclaration|TypeAliasDeclaration|TypeNode} statement
	 * @returns {TypeExpression}
	 */
	private getTypeExpression (statement: ParameterDeclaration | TypeAliasDeclaration | TypeNode): TypeExpression {

		if (this.isTypeNode(statement)) {
			if ((this.isTypeReferenceNode(statement) || this.isTypeReference(statement)) && this.isIdentifierObject(statement.typeName)) {
				const name = statement.typeName.text;
				let typeArguments: TypeExpression | null = null;
				const typeArgs = statement.typeArguments;

				if (typeArgs != null) {
					typeArgs.forEach((typeArgument, index) => {
						const value = this.getTypeExpression(typeArgument);
						value.forEach(part => {
							if (typeArguments == null) typeArguments = [];
							typeArguments.push(part);
							if (index !== typeArgs.length - 1) typeArguments.push(", ");
						});
					});
				}
				return [{name, typeArguments}];
			}

			if (this.isArrayTypeNode(statement)) {
				return [...this.getTypeExpression(statement.elementType), "[", "]"];
			}

			if (this.isTupleTypeNode(statement)) {
				const exp: TypeExpression = [];
				exp.push("[");

				statement.elementTypes.forEach((type, index) => {
					const value = this.getTypeExpression(type);
					value.forEach(part => exp.push(part));
					if (index !== statement.elementTypes.length - 1) exp.push(", ");
				});
				exp.push("]");
				return exp;
			}

			if (this.isIntersectionTypeNode(statement)) {
				const exp: TypeExpression = [];

				statement.types.forEach((intersectionType, index) => {
					const value = this.getTypeExpression(intersectionType);

					value.forEach(part => exp.push(part));
					if (index !== statement.types.length - 1) exp.push(" & ");
				});
				return exp;
			}

			if (this.isUnionTypeNode(statement)) {
				const exp: TypeExpression = [];

				statement.types.forEach((unionType, index) => {
					const value = this.getTypeExpression(unionType);

					value.forEach(part => exp.push(part));
					if (index !== statement.types.length - 1) exp.push("|");
				});
				return exp;
			}

			return [this.serializeToken(statement.kind)];
		}

		if (this.isTypeLiteralNode(statement)) {
			const exp: TypeExpression = ["{"];

			statement.members.forEach((member, index) => {

				if (this.isIndexSignatureDeclaration(member)) {
					exp.push("[");

					member.parameters.forEach(parameter => {
						exp.push(<string>this.getNameOfMember(parameter.name, false, true));
						if (parameter.type != null) {
							exp.push(": ");
							const type = this.getTypeExpression(parameter.type);
							type.forEach(part => exp.push(part));
						}
						exp.push("]");

					});
					if (member.type != null) {
						exp.push(": ");
						const type = this.getTypeExpression(member.type);
						type.forEach(part => exp.push(part));
					}
				}

				if (this.isPropertySignature(member)) {
					const name = <string>this.getNameOfMember(member.name, false, true);
					const type = member.type == null ? null : this.getTypeExpression(member.type);
					exp.push(name);

					if (member.questionToken != null) {
						exp.push(this.serializeToken(member.questionToken.kind));
					}
					if (type != null) {
						exp.push(": ");
						type.forEach(part => exp.push(part));
					}
				}

				if (index !== statement.members.length - 1) exp.push(", ");

			});
			exp.push("}");
			return exp;
		}

		if (this.isTypeReference(statement) && this.isIdentifierObject(statement.typeName)) {
			const name = statement.typeName.text;
			let typeArguments: TypeExpression | null = null;
			const typeArgs = statement.typeArguments;
			if (typeArgs != null) {
				typeArgs.forEach((typeArgument, index) => {
					const value = this.getTypeExpression(typeArgument);
					value.forEach(part => {
						if (typeArguments == null) typeArguments = [];
						typeArguments.push(part);
						if (index !== typeArgs.length - 1) typeArguments.push(", ");
					});
				});
			}
			return [{name, typeArguments}];
		}

		if (this.isExpressionWithTypeArguments(statement)) {
			const name = this.getNameOfMember(statement.expression, false, true);
			let typeArguments: TypeExpression | null = null;
			const typeArgs = statement.typeArguments;
			if (typeArgs != null) {
				typeArgs.forEach((typeArgument, index) => {
					const value = this.getTypeExpression(typeArgument);
					value.forEach(part => {
						if (typeArguments == null) typeArguments = [];
						typeArguments.push(part);
						if (index !== typeArgs.length - 1) typeArguments.push(", ");
					});
				});
			}
			return [{name, typeArguments}];
		}

		if (statement.type != null) return this.getTypeExpression(statement.type);
		throw new TypeError(`${this.getTypeExpression.name} could not retrieve the type information for a statement of kind ${SyntaxKind[statement.kind]}`);
	}

	/**
	 * Takes all ITypeBindings from a TypeExpression and returns an array of them.
	 * @param {TypeExpression} expression
	 * @param {boolean} [deep=false]
	 * @returns {ITypeBinding[]}
	 */
	private takeTypeBindings (expression: TypeExpression, deep: boolean = false): ITypeBinding[] {
		const bindings: ITypeBinding[] = [];

		expression.forEach(token => {
			if (this.isTypeBinding(token)) {
				bindings.push(token);

				if (token.typeArguments != null && deep) {
					this.takeTypeBindings(token.typeArguments, deep).forEach(typeBinding => bindings.push(typeBinding));
				}
			}
		});
		return bindings;
	}


	/**
	 * Formats and returns a string representation of a type.
	 * @param {TypeExpression} expression
	 * @returns {string}
	 */
	private serializeTypeExpression (expression: TypeExpression): string {
		let statement: string = "";
		expression.forEach(token => {
			if (this.isTypeBinding(token)) {
				statement += token.name;
				if (token.typeArguments != null) {
					statement += `<${this.serializeTypeExpression(token.typeArguments)}>`;
				}
			} else {
				statement += `${token}`;
			}
		});
		return statement;
	}

	/**
	 * Formats the decorators of the given declaration and returns a DecoratorIndexer.
	 * @param {PropertyDeclaration|ClassDeclaration|MethodDeclaration} declaration
	 * @returns {DecoratorIndexer}
	 */
	private formatDecorators(declaration: PropertyDeclaration | ClassDeclaration | MethodDeclaration | ConstructorDeclaration): DecoratorIndexer {
		const obj: DecoratorIndexer = {};
		if (declaration.decorators == null) return obj;

		declaration.decorators.forEach(decorator => {
			const name = <string>this.getNameOfMember(decorator.expression, false, true);
			obj[name] = { name };
		});
		return obj;
	}

	/**
	 * Takes a PropertyDeclaration and returns an IPropDeclaration.
	 * @param {PropertyDeclaration} declaration
	 * @returns {IPropDeclaration}
	 */
	private formatPropertyDeclaration (declaration: PropertyDeclaration): IPropDeclaration {
		const startsAt = declaration.pos;
		const endsAt = declaration.end;
		const name = <string>this.getNameOfMember(declaration.name, false, true);
		const typeExpression = declaration.type == null ? null : this.getTypeExpression(declaration.type);
		const typeFlattened = typeExpression == null ? null : this.serializeTypeExpression(typeExpression);
		const typeBindings = typeExpression == null ? null : this.takeTypeBindings(typeExpression);
		const valueExpression = declaration.initializer == null ? null : this.getValueExpression(declaration.initializer);
		// TODO: Resolve value!
		const valueResolved = "";
		return {
			startsAt,
			endsAt,
			name,
			type: {
				expression: typeExpression,
				flattened: typeFlattened,
				bindings: typeBindings
			},
			decorators: this.formatDecorators(declaration),
			value: {
				expression: valueExpression,
				resolved: valueResolved
			}
		};
	}

	/**
	 * Takes a PropertyDeclaration and returns an IPropDeclaration.
	 * @param {NodeArray<HeritageClause>} clauses
	 * @returns {IPropDeclaration}
	 */
	private formatHeritageClauses (clauses: NodeArray<HeritageClause>): IHeritage {
		const obj: IHeritage = {extendsClass: null, implementsInterfaces: []};

		clauses.forEach(clause => {

			if (this.isExtendsClause(clause)) {
				// There can only be one extended class.
				const [classIdentifier] = clause.types;
				const [extendsClass] = this.getTypeExpression(classIdentifier);
				if (this.isTypeBinding(extendsClass)) {
					obj.extendsClass = extendsClass;
				}
			}

			if (this.isImplementsClause(clause)) {
				clause.types.forEach(identifier => {
					const expression = this.getTypeExpression(identifier);
					expression.forEach(part => {
						if (this.isTypeBinding(part)) {
							obj.implementsInterfaces.push(part);
						}
					});
				});
			}
		});
		return obj;
	}

	/**
	 * Formats a concrete ParameterDeclaration and returns an IParameter.
	 * @param {ParameterDeclaration} parameter
	 * @returns {IParameter}
	 */
	private formatParameter (parameter: ParameterDeclaration): IParameter {
		const startsAt = parameter.pos;
		const endsAt = parameter.end;
		const name = <string>this.getNameOfMember(parameter.name, false, true);
		const typeExpression = parameter.type == null ? null : this.getTypeExpression(parameter);
		const typeFlattened = typeExpression == null ? null : this.serializeTypeExpression(typeExpression);
		const typeBindings = typeExpression == null ? null : this.takeTypeBindings(typeExpression);
		const valueExpression = parameter.initializer != null ? this.getValueExpression(parameter.initializer) : null;
		// TODO: Compute this!
		const valueResolved = "";
		return {
			startsAt,
			endsAt,
			name,
			type: {
				expression: typeExpression,
				flattened: typeFlattened,
				bindings: typeBindings
			},
			value: {
				expression: valueExpression,
				resolved: valueResolved
			}
		};
	}

	/**
	 * Formats a concrete ParameterDeclaration and returns an IArgument.
	 * @param {Expression} argument
	 * @returns {IArgument}
	 */
	private formatArgument (argument: Expression): IArgument {
		const startsAt = argument.pos;
		const endsAt = argument.end;
		const valueExpression = this.getValueExpression(argument);
		// TODO: Compute this!
		const valueResolved = "";
		return {
			startsAt,
			endsAt,
			value: {
				expression: valueExpression,
				resolved: valueResolved
			}
		};
	}

	/**
	 * Takes the parameters from a ConstructorDeclaration or a MethodDeclaration and returns an array of IParameters.
	 * @param {ConstructorDeclaration | MethodDeclaration} declaration
	 * @returns {IParameter[]}
	 */
	private formatParameters (declaration: ConstructorDeclaration | MethodDeclaration): IParameter[] {
		return declaration.parameters.map(param => this.formatParameter(param));
	}

	/**
	 * Takes the arguments from a CallExpression and returns an array of IArguments.
	 * @param {CallExpression} declaration
	 * @returns {IArgument[]}
	 */
	private formatArguments (declaration: CallExpression|NewExpression): IArgument[] {
		return declaration.arguments == null ? [] : declaration.arguments.map(arg => this.formatArgument(arg));
	}

	/**
	 * Returns true if the current item should be converted to an indexed lookup.
	 * @param {ArbitraryValue} previous
	 * @param {ArbitraryValue} current
	 * @returns {boolean}
	 */	
	private shouldBeIndexedLookup(previous: ArbitraryValue, current: ArbitraryValue): boolean {
		if ((previous instanceof BindingIdentifier) && current instanceof BindingIdentifier) return true;
		if (this.isIndexedLookup(previous)) return true;
		return false;
	}

	/**
	 * Returns true if the given item is an indexed lookup.
	 * @param {ArbitraryValue} item
	 * @returns {boolean}
	 */
	private isIndexedLookup(item: ArbitraryValue): boolean {
		return typeof item === "string" && (item.startsWith("[") || item.endsWith("]"));
	}

	/**
	 * Normalizes an indexed lookup or a dotted lookup into an indexed one
	 * @param {ArbitraryValue} path
	 * @returns {string}
	 */
	public convertToIndexedLookup(path: ArbitraryValue): string {
		if (this.isOperatorLike(path)) return path == null ? "" : path.toString();

		if (typeof path === "string") {
			if (this.isIndexedLookup(path)) return path;
			return `["${path}"]`;
		}
			
		return `[${path}]`;
	}

	/**
	 * Takes a ConstructorDeclaration or a MethodDeclaration and returns an IMemberDeclaration.
	 * @param {ConstructorDeclaration|MethodDeclaration} declaration
	 * @param {string} fileContents
	 * @returns {IMemberDeclaration}
	 */
	private formatCallableMemberDeclaration (declaration: ConstructorDeclaration | MethodDeclaration, fileContents: string): IMemberDeclaration & IParametersable {
		const startsAt = declaration.pos;
		const endsAt = declaration.end;
		const body = declaration.body;
		const argumentsStartsAt = declaration.parameters.pos;
		const argumentsEndsAt = declaration.parameters.end;

		const bodyStartsAt = body == null ? -1 : body.pos;
		const bodyEndsAt = body == null ? -1 : body.end;
		const contents = fileContents.slice(startsAt, endsAt);
		const bodyContents = body == null ? null : fileContents.slice(bodyStartsAt, bodyEndsAt);

		return {
			startsAt,
			endsAt,
			contents,
			decorators: this.formatDecorators(declaration),
			body: {
				startsAt: bodyStartsAt,
				endsAt: bodyEndsAt,
				contents: bodyContents
			},
			parameters: {
				startsAt: argumentsStartsAt,
				endsAt: argumentsEndsAt,
				parametersList: this.formatParameters(declaration)
			}
		};
	}

	/**
	 * Takes a ConstructorDeclaration and returns an IConstructorDeclaration.
	 * @param {ConstructorDeclaration} declaration
	 * @param {string} fileContents
	 * @returns {IConstructorDeclaration}
	 */
	private formatConstructorDeclaration (declaration: ConstructorDeclaration, fileContents: string): IConstructorDeclaration {
		const name = "constructor";
		return {...this.formatCallableMemberDeclaration(declaration, fileContents), ...{name}};
	}

	/**
	 * Takes a MethodDeclaration and returns an IMethodDeclaration.
	 * @param {MethodDeclaration} declaration
	 * @param {string} fileContents
	 * @returns {IMethodDeclaration}
	 */
	private formatMethodDeclaration (declaration: MethodDeclaration, fileContents: string): IMethodDeclaration {
		const name = <string>this.getNameOfMember(declaration.name, false, true);
		let returnStatementStartsAt: number = -1;
		let returnStatementEndsAt: number = -1;
		let returnStatementContents: string | null = null;

		if (declaration.body != null && declaration.body.statements != null) {
			declaration.body.statements.forEach(bodyStatement => {

				if (this.isReturnStatement(bodyStatement)) {
					if (bodyStatement.expression != null) {
						returnStatementStartsAt = bodyStatement.expression.pos;
						returnStatementEndsAt = bodyStatement.expression.end;
						returnStatementContents = fileContents.slice(returnStatementStartsAt, returnStatementEndsAt);
					}
				}
			});
		}

		return {
			...this.formatCallableMemberDeclaration(declaration, fileContents),
			...{name, returnStatementStartsAt, returnStatementEndsAt, returnStatementContents}
		};
	}

	/**
	 * Walks up the inheritance chain from the given statement until it finds a SourceFile and returns an ISourceFileProperties object.
	 * @param {Statement} statement
	 * @returns {ISourceFileProperties}
	 */
	private getSourceFileProperties(statement: Statement|Node|Expression): ISourceFileProperties {
		let current: Statement|Node = statement;
		
		while (!this.isSourceFile(current)) {
			if (current.parent == null) break;
			current = current.parent;
		}

		if (!this.isSourceFile(current)) {
			throw new TypeError(`${this.getSourceFileProperties.name} could not find a source file from a given statement of kind ${SyntaxKind[statement.kind]}`);
		}

		return {
			filePath: current.fileName,
			fileContents: current.text
		}
	}

	/**
	 * Gets a class declaration, including its methods, positions, which class it derives from,
	 * props and constructor parameters.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {IClassDeclaration}
	 */
	private getClassDeclaration (statement: ClassDeclaration): IClassDeclaration | null {
		if (statement.name == null) return null;
		const sourceFileProperties = this.getSourceFileProperties(statement);
		const filePath = sourceFileProperties.filePath;
		const fileContents = sourceFileProperties.fileContents;

		const className = statement.name.text;
		const classDeclarationStartsAt = statement.pos;
		const classDeclarationEndsAt = statement.end;
		const classBodyStartsAt = statement.members.pos;
		const classBodyEndsAt = statement.members.end;
		const fullClassContents = fileContents.slice(classDeclarationStartsAt, classDeclarationEndsAt);
		const bodyClassContents = fileContents.slice(classBodyStartsAt, classBodyEndsAt);

		const declaration: IClassDeclaration = {
			name: className,
			filePath,
			methods: {},
			heritage: statement.heritageClauses == null ? null : this.formatHeritageClauses(statement.heritageClauses),
			decorators: this.formatDecorators(statement),
			constructor: null,
			startsAt: classDeclarationStartsAt,
			endsAt: classDeclarationEndsAt,
			contents: fullClassContents,
			body: {
				startsAt: classBodyStartsAt,
				endsAt: classBodyEndsAt,
				contents: bodyClassContents
			},
			props: {}
		};

		statement.members.forEach(member => {

			if (this.isPropertyDeclaration(member)) {
				const formatted = this.formatPropertyDeclaration(member);
				declaration.props[formatted.name] = formatted;
			}

			else if (this.isConstructorDeclaration(member)) {
				declaration.constructor = this.formatConstructorDeclaration(member, fileContents);
			}

			else if (this.isMethodDeclaration(member)) {
				const formatted = this.formatMethodDeclaration(member, fileContents);
				declaration.methods[formatted.name] = formatted;
			}

			else throw new TypeError(`${this.getClassDeclaration.name} didn't understand a class member of type ${SyntaxKind[member.kind]}`);
		});

		return declaration;
	}

	// /**
	//  * Finds a free enum ordinal value. Free meaning that no other member of the enumeration is initialized to that value.
	//  * @param {Set<number>} taken
	//  * @returns {number}
	//  */
	// private findFreeEnumIntegerValue (taken: Set<number>): number {
	// 	const sorted = [...taken].sort();
	//
	// 	for (let i = 0; i < sorted.length; i++) {
	// 		if (taken.has(i)) continue;
	// 		return i;
	// 	}
	// 	return sorted.length;
	// }
	//
	// /**
	//  * Walks through an enumeration and checks the associated ordinal values.
	//  * @param {EnumDeclaration} statement
	//  * @returns NullableInitializationValue}
	//  */
	// private getValueExpressionsForEnum (statement: EnumDeclaration): NullableInitializationValue {
	// 	const props: { [key: string]: NullableInitializationValue } = {};
	// 	const taken: Set<number> = new Set();
	// 	statement.members.forEach(member => {
	// 		// TODO: Typescript doesn't think that a 'text' key exists here. Why?
	// 		const value = (<Identifier>member.name).text;
	// 		const initializer = member.initializer;
	// 		// TODO: Remove any declaration.
	// 		const integerValue = initializer == null ? this.findFreeEnumIntegerValue(taken) : parseInt((<any>initializer).text);
	//
	// 		taken.add(integerValue);
	//
	// 		if (value != null) props[value] = [integerValue];
	// 	});
	// 	return [props];
	// }

}