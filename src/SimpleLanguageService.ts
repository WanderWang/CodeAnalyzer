import {IMarshaller} from "@wessberg/marshaller";
import {dirname, join} from "path";
import * as ts from "typescript";
import {ArrayBindingPattern, ArrayLiteralExpression, ArrayTypeNode, ArrowFunction, BinaryExpression, BindingName, BindingPattern, Block, BooleanLiteral, CallExpression, ClassDeclaration, CompilerOptions, ComputedPropertyName, ConditionalExpression, ConstructorDeclaration, Declaration, DeclarationName, ElementAccessExpression, EntityName, EnumDeclaration, ExportDeclaration, Expression, ExpressionStatement, FunctionExpression, HeritageClause, Identifier, ImportDeclaration, IndexSignatureDeclaration, IntersectionTypeNode, IScriptSnapshot, KeywordTypeNode, LanguageService, MethodDeclaration, ModuleKind, NamedImports, NewExpression, Node, NodeArray, NoSubstitutionTemplateLiteral, NumericLiteral, ObjectBindingPattern, ObjectLiteralExpression, ParameterDeclaration, ParenthesizedExpression, PrefixUnaryExpression, PropertyAccessExpression, PropertyAssignment, PropertyDeclaration, PropertyName, PropertySignature, ReturnStatement, ScriptTarget, SpreadAssignment, SpreadElement, Statement, StringLiteral, TemplateExpression, TemplateHead, TemplateSpan, TemplateTail, ThisExpression, Token, TupleTypeNode, TypeAliasDeclaration, TypeAssertion, TypeLiteralNode, TypeNode, TypeReferenceNode, UnionTypeNode, VariableStatement, SyntaxKind} from "typescript";
import {BindingIdentifier} from "./BindingIdentifier";
import {ArbitraryValue, AssignmentMap, IArgument, ICallExpression, IClassDeclaration, IConstructorDeclaration, IHeritage, IMemberDeclaration, IMethodDeclaration, IModuleDependency, InitializationValue, IParameter, IParametersable, IPropDeclaration, ISimpleLanguageService, ITypeBinding, TypeExpression, INewExpression, ITypeable, ICallable} from "./interface/ISimpleLanguageService";
import {ISimpleLanguageServiceConfig} from "./interface/ISimpleLanguageServiceConfig";

/**
 * A service that parses and reflects on the AST generated by Typescript's language service.
 * With it, we can extract metadata such as initialization values and types, arguments and import
 * declarations.
 * @author Frederik Wessberg
 */
export class SimpleLanguageService implements ISimpleLanguageService {
	private languageService: LanguageService;
	private files: Map<string, { version: number, content: string }> = new Map();

	constructor (private marshaller: IMarshaller,
							 private config: ISimpleLanguageServiceConfig = {},
							 private typescript: typeof ts = ts) {
		this.languageService = this.typescript.createLanguageService(this, typescript.createDocumentRegistry());
	}

	/**
	 * Adds a new file to the LanguageService.
	 * @param {string} fileName
	 * @param {string} content
	 * @param {number} [version=0]
	 * @returns {void}
	 */
	public addFile (fileName: string, content: string, version: number = 0): NodeArray<Statement> {
		this.files.set(fileName, {version, content});
		return this.languageService.getProgram().getSourceFile(fileName).statements;
	}

	/**
	 * Gets the settings that Typescript will generate an AST from. There isn't much reason to make
	 * anything but the libs developer-facing since we only support ES2015 modules.
	 * @returns {CompilerOptions}
	 */
	public getCompilationSettings (): CompilerOptions {
		return {
			target: ScriptTarget.ES2017,
			module: ModuleKind.ES2015,
			lib: this.config.lib != null && this.config.lib.length > 0
				? this.config.lib
				: ["es2015.promise", "dom", "es6", "scripthost", "es7", "es2017.object", "es2015.proxy"]
		};
	}

	/**
	 * Gets the names of each file that has been added to the "program".
	 * @returns {string[]}
	 */
	public getScriptFileNames (): string[] {
		return [...this.files.keys()];
	}

	/**
	 * Gets the last version of the given fileName. Each time a file changes, the version number will be updated,
	 * so this can be useful to figure out if the file has changed since the program was run initially.
	 * @param {string} fileName
	 * @returns {string}
	 */
	public getScriptVersion (fileName: string): string {
		const script = this.files.get(fileName);
		if (script == null) return "-1";
		return script.version.toString();
	}

	/**
	 * Gets the last registered IScriptSnapshot, if any, otherwise undefined.
	 * @param {string} fileName
	 * @returns {IScriptSnapshot?}
	 */
	public getScriptSnapshot (fileName: string): IScriptSnapshot | undefined {
		const file = this.files.get(fileName);
		if (file == null) return undefined;
		return this.typescript.ScriptSnapshot.fromString(file.content);
	}

	/**
	 * Gets the current directory.
	 * @returns {string}
	 */
	public getCurrentDirectory (): string {
		return process.cwd();
	}

	/**
	 * Gets the default filepath for Typescript's lib-files.
	 * @param {CompilerOptions} options
	 * @returns {string}
	 */
	public getDefaultLibFileName (options: CompilerOptions): string {
		return this.typescript.getDefaultLibFilePath(options);
	}

	/**
	 * A predicate function that returns true if the given Statement is an ObjectLiteralExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isObjectLiteralExpression (statement: Statement | Declaration | Expression | Node): statement is ObjectLiteralExpression {
		return statement.kind === SyntaxKind.ObjectLiteralExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a VariableStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isVariableDeclaration (statement: Statement | Declaration | Expression | Node): statement is VariableStatement {
		return statement.kind === SyntaxKind.VariableStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a PropertyAccessExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPropertyAccessExpression (statement: Statement | Declaration | Expression | Node): statement is PropertyAccessExpression {
		return statement.kind === SyntaxKind.PropertyAccessExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a PropertyDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPropertyDeclaration (statement: Statement | Declaration | Expression | Node): statement is PropertyDeclaration {
		return statement.kind === SyntaxKind.PropertyDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is a PropertySignature.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPropertySignature (statement: Statement | Declaration | Expression | Node): statement is PropertySignature {
		return statement.kind === SyntaxKind.PropertySignature;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ElementAccessExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isElementAccessExpression (statement: Statement | Declaration | Expression | Node): statement is ElementAccessExpression {
		return statement.kind === SyntaxKind.ElementAccessExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ArrayLiteralExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isArrayLiteralExpression (statement: Statement | Declaration | Expression | Node): statement is ArrayLiteralExpression {
		return statement.kind === SyntaxKind.ArrayLiteralExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeAssertion.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTypeAssertionExpression (statement: Statement | Declaration | Expression | Node): statement is TypeAssertion {
		return statement.kind === SyntaxKind.TypeAssertionExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an NoSubstitutionTemplateLiteral.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNoSubstitutionTemplateLiteral (statement: Statement | Declaration | Expression | Node): statement is NoSubstitutionTemplateLiteral {
		return statement.kind === SyntaxKind.NoSubstitutionTemplateLiteral;
	}

	/**
	 * A predicate function that returns true if the given Statement is a a TemplateExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTemplateExpression (statement: Statement | Declaration | Expression | Node): statement is TemplateExpression {
		return statement.kind === SyntaxKind.TemplateExpression || statement.kind === SyntaxKind.TaggedTemplateExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a an ArrowFunction.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isArrowFunction (statement: Statement | Declaration | Expression | Node): statement is ArrowFunction {
		return statement.kind === SyntaxKind.ArrowFunction;
	}

	/**
	 * A predicate function that returns true if the given Statement is a a FunctionExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isFunctionExpression (statement: Statement | Declaration | Expression | Node): statement is FunctionExpression {
		return statement.kind === SyntaxKind.FunctionExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an TemplateSpan.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTemplateSpan (statement: Statement | Declaration | Expression | Node): statement is TemplateSpan {
		return statement.kind === SyntaxKind.TemplateSpan;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ConditionalExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isConditionalExpression (statement: Statement | Declaration | Expression | Node): statement is ConditionalExpression {
		return statement.kind === SyntaxKind.ConditionalExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an CallExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isCallExpression (statement: Statement | Declaration | Expression | Node): statement is CallExpression {
		return statement.kind === SyntaxKind.CallExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a PrefixUnaryExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPrefixUnaryExpression (statement: Statement | Declaration | Expression | Node): statement is PrefixUnaryExpression {
		return statement.kind === SyntaxKind.PrefixUnaryExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ParenthesizedExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 */
	public isParenthesizedExpression (statement: Statement | Declaration | Expression | Node): statement is ParenthesizedExpression {
		return statement.kind === SyntaxKind.ParenthesizedExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ParameterDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isParameterDeclaration (statement: Statement | Declaration | Expression | Node): statement is ParameterDeclaration {
		return statement.kind === SyntaxKind.Parameter;
	}

	/**
	 * A predicate function that returns true if the given Statement is a BinaryExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isBinaryExpression (statement: Statement | Declaration | Expression | Node): statement is BinaryExpression {
		return statement.kind === SyntaxKind.BinaryExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ImportDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isImportDeclaration (statement: Statement | Declaration | Expression | Node): statement is ImportDeclaration {
		return statement.kind === SyntaxKind.ImportDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is am EnumDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isEnumDeclaration (statement: Statement | Declaration | Expression | Node): statement is EnumDeclaration {
		return statement.kind === SyntaxKind.EnumDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'true'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTrueKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is BooleanLiteral {
		return statement.kind === SyntaxKind.TrueKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'false'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isFalseKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is BooleanLiteral {
		return statement.kind === SyntaxKind.FalseKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'undefined'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isUndefinedKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.UndefinedKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'null'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNullKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.NullKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'string'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isStringKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.StringKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'symbol'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isSymbolKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.SymbolKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'void'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isVoidKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.VoidKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'any'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isAnyKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.AnyKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'boolean'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isBooleanKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.BooleanKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'never'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNeverKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.NeverKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'number'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNumberKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.NumberKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is a NumericLiteral.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNumericLiteral (statement: TypeNode | Statement | Declaration | Expression | Node): statement is NumericLiteral {
		return statement.kind === SyntaxKind.NumericLiteral;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ObjectBindingPattern.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isObjectBindingPattern (statement: TypeNode | Statement | Declaration | Expression | Node): statement is ObjectBindingPattern {
		return statement.kind === SyntaxKind.ObjectBindingPattern;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ArrayBindingPattern.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isArrayBindingPattern (statement: TypeNode | Statement | Declaration | Expression | Node): statement is ArrayBindingPattern {
		return statement.kind === SyntaxKind.ArrayBindingPattern;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ArrayBindingPattern.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isBindingPattern (statement: TypeNode | Statement | Declaration | Expression | Node): statement is BindingPattern {
		return this.isObjectBindingPattern(statement) || this.isArrayBindingPattern(statement);
	}

	/**
	 * A predicate function that returns true if the given Statement is a PropertyName.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPropertyName (statement: Expression | Node): statement is PropertyName {
		return this.isIdentifierObject(statement) ||
			this.isStringLiteral(statement) ||
			this.isNumericLiteral(statement) ||
			this.isComputedPropertyName(statement);
	}

	/**
	 * A predicate function that returns true if the given Statement is a DeclarationName.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isDeclarationName (statement: Expression | Node): statement is DeclarationName {
		return this.isPropertyName(statement) || this.isBindingPattern(statement);
	}

	/**
	 * A predicate function that returns true if the given Statement is a TemplateHead.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTemplateHead (statement: TypeNode | Statement | Declaration | Expression | Node): statement is TemplateHead {
		return statement.kind === SyntaxKind.TemplateHead;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TemplateTail.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTemplateTail (statement: TypeNode | Statement | Declaration | Expression | Node): statement is TemplateTail {
		return statement.kind === SyntaxKind.TemplateTail;
	}

	/**
	 * A predicate function that returns true if the given Statement is a StringLiteral.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isStringLiteral (statement: TypeNode | Statement | Declaration | Expression | Node): statement is StringLiteral {
		return statement.kind === SyntaxKind.StringLiteral;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'object'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isObjectKeyword (statement: TypeNode | Statement | Declaration | Expression | Node): statement is KeywordTypeNode {
		return statement.kind === SyntaxKind.ObjectKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is the keyword 'this'.
	 * @param {TypeNode|Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isThisKeyword (statement: Statement | Declaration | Expression | Node): statement is ThisExpression {
		return statement.kind === SyntaxKind.ThisKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeNode
	 * @param {ParameterDeclaration|TypeAliasDeclaration|TypeNode} statement
	 * @returns {boolean}
	 */
	public isTypeNode (statement: ParameterDeclaration | TypeAliasDeclaration | TypeNode): statement is TypeNode {
		return this.isThisKeyword(statement) ||
			this.isArrayTypeNode(statement) ||
			this.isTupleTypeNode(statement) ||
			this.isIntersectionTypeNode(statement) ||
			this.isUnionTypeNode(statement) ||
			this.isObjectKeyword(statement) ||
			this.isNumberKeyword(statement) ||
			this.isNeverKeyword(statement) ||
			this.isBooleanKeyword(statement) ||
			this.isAnyKeyword(statement) ||
			this.isVoidKeyword(statement) ||
			this.isSymbolKeyword(statement) ||
			this.isStringKeyword(statement) ||
			this.isNullKeyword(statement) ||
			this.isUndefinedKeyword(statement) ||
			this.isTrueKeyword(statement) ||
			this.isFalseKeyword(statement);
	}

	/**
	 * A predicate function that returns true if the given Statement is a PropertyAssignment.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isPropertyAssignment (statement: Statement | Declaration | Expression | Node): statement is PropertyAssignment {
		return statement.kind === SyntaxKind.PropertyAssignment;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ExpressionStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isExpressionStatement(statement: Statement | Declaration | Expression | Node): statement is ExpressionStatement {
		return statement.kind === SyntaxKind.ExpressionStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a SpreadAssignment.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isSpreadAssignment (statement: Statement | Declaration | Expression | Node): statement is SpreadAssignment {
		return statement.kind === SyntaxKind.SpreadAssignment;
	}

	/**
	 * A predicate function that returns true if the given Statement is a SpreadElement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isSpreadElement (statement: Statement | Declaration | Expression | Node): statement is SpreadElement {
		return statement.kind === SyntaxKind.SpreadElement;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeReferenceNode.
	 * @param {ParameterDeclaration|TypeReferenceNode|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isTypeReference (statement: ParameterDeclaration | TypeReferenceNode | TypeNode | TypeAliasDeclaration): statement is TypeReferenceNode {
		return statement.kind === SyntaxKind.TypeReference;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeLiteralNode.
	 * @param {ParameterDeclaration|TypeReferenceNode|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isTypeLiteralNode (statement: ParameterDeclaration | TypeReferenceNode | TypeNode | TypeAliasDeclaration): statement is TypeLiteralNode {
		return statement.kind === SyntaxKind.TypeLiteral;
	}

	/**
	 * A predicate function that returns true if the given Statement is an IndexSignatureDeclaration.
	 * @param {ParameterDeclaration|TypeReferenceNode|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isIndexSignatureDeclaration (statement: Declaration): statement is IndexSignatureDeclaration {
		return statement.kind === SyntaxKind.IndexSignature;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ClassDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isClassDeclaration (statement: Statement | Declaration | Expression | Node): statement is ClassDeclaration {
		return statement.kind === SyntaxKind.ClassDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ConstructorDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isConstructorDeclaration (statement: Statement | Declaration | Expression | Node): statement is ConstructorDeclaration {
		return statement.kind === SyntaxKind.Constructor;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TypeReferenceNode.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isTypeReferenceNode (statement: Statement | Declaration | Expression | Node): statement is TypeReferenceNode {
		return statement.kind === SyntaxKind.TypeReference;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ArrayTypeNode.
	 * @param {ParameterDeclaration|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isArrayTypeNode (statement: ParameterDeclaration | TypeNode | TypeAliasDeclaration): statement is ArrayTypeNode {
		return statement.kind === SyntaxKind.ArrayType;
	}

	/**
	 * A predicate function that returns true if the given Statement is a TupleTypeNode.
	 * @param {ParameterDeclaration|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isTupleTypeNode (statement: ParameterDeclaration | TypeNode | TypeAliasDeclaration): statement is TupleTypeNode {
		return statement.kind === SyntaxKind.TupleType;
	}

	/**
	 * A predicate function that returns true if the given Statement is a UnionTypeNode.
	 * @param {ParameterDeclaration|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isUnionTypeNode (statement: ParameterDeclaration | TypeNode | TypeAliasDeclaration): statement is UnionTypeNode {
		return statement.kind === SyntaxKind.UnionType;
	}

	/**
	 * A predicate function that returns true if the given Statement is a IntersectionTypeNode.
	 * @param {ParameterDeclaration|TypeNode|TypeAliasDeclaration} statement
	 * @returns {boolean}
	 */
	public isIntersectionTypeNode (statement: ParameterDeclaration | TypeNode | TypeAliasDeclaration): statement is IntersectionTypeNode {
		return statement.kind === SyntaxKind.IntersectionType;
	}

	/**
	 * A predicate function that returns true if the given Statement is a MethodDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isMethodDeclaration (statement: Statement | Declaration | Expression | Node): statement is MethodDeclaration {
		return statement.kind === SyntaxKind.MethodDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is a NewExpression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNewExpression (statement: Statement | Declaration | Expression | Node): statement is NewExpression {
		return statement.kind === SyntaxKind.NewExpression;
	}

	/**
	 * A predicate function that returns true if the given Statement is a Block.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isBlockDeclaration (statement: Statement | Declaration | Expression | Node): statement is Block {
		return statement.kind === SyntaxKind.Block;
	}

	/**
	 * A predicate function that returns true if the given Statement is a ReturnStatement.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isReturnStatement (statement: Statement | Declaration | Expression | Node): statement is ReturnStatement {
		return statement.kind === SyntaxKind.ReturnStatement;
	}

	/**
	 * A predicate function that returns true if the given Statement is an ExportDeclaration.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isExportDeclaration (statement: Statement | Declaration | Expression | Node): statement is ExportDeclaration {
		return statement.kind === SyntaxKind.ExportDeclaration;
	}

	/**
	 * A predicate function that returns true if the given Statement is an Identifier.
	 * @param {BindingName|EntityName|Expression} statement
	 * @returns {boolean}
	 */
	public isIdentifierObject (statement: BindingName | EntityName | Expression | Node): statement is Identifier {
		return statement != null && statement.constructor.name === "IdentifierObject";
	}

	/**
	 * A predicate function that returns true if the given Statement is a TokenObject.
	 * @param {BindingName|EntityName|Expression} statement
	 * @returns {boolean}
	 */
	public isTokenObject (statement: BindingName | EntityName | Expression | Node): statement is Token<SyntaxKind> {
		return statement != null && statement.constructor.name === "TokenObject";
	}

	/**
	 * A predicate function that returns true if the given Statement is a FirstLiteralToken.
	 * @param {BindingName|EntityName|Expression} statement
	 * @returns {boolean}
	 */
	public isFirstLiteralToken (statement: BindingName | EntityName | Expression | Node): statement is Token<SyntaxKind.FirstLiteralToken> & { text: string } {
		return statement.kind === SyntaxKind.FirstLiteralToken;
	}


	/**
	 * A predicate function that returns true if the given Statement is a ComputedPropertyName.
	 * @param {BindingName|EntityName|Expression} statement
	 * @returns {boolean}
	 */
	public isComputedPropertyName (statement: BindingName | EntityName | Expression | Node): statement is ComputedPropertyName {
		return statement.kind === SyntaxKind.ComputedPropertyName;
	}

	/**
	 * A predicate function that returns true if the given Statement is a HeritageClause.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isExtendsClause (statement: Statement | Declaration | Expression | Node): statement is HeritageClause {
		// Extends will always be a 'token', not a 'kind'.
		return (<HeritageClause>statement).token === SyntaxKind.ExtendsKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is a HeritageClause.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isImplementsClause (statement: Statement | Declaration | Expression | Node): statement is HeritageClause {
		// Extends will always be a 'token', not a 'kind'.
		return (<HeritageClause>statement).token === SyntaxKind.ImplementsKeyword;
	}

	/**
	 * A predicate function that returns true if the given Statement is a NamedImports expression.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @returns {boolean}
	 */
	public isNamedImports (statement: Statement | Declaration | Expression | Node): statement is NamedImports {
		// Extends will always be a 'token', not a 'kind'.
		return statement.kind === SyntaxKind.NamedImports;
	}

	/**
	 * A predicate function that returns true if an expression is a ITypeBinding.
	 * @param {ArbitraryValue} expression
	 * @returns {boolean}
	 */
	private isTypeBinding (expression: ArbitraryValue): expression is ITypeBinding {
		const exp = <ITypeBinding>expression;
		return exp.name != null && (exp.typeArguments === null || Array.isArray(exp.typeArguments));
	}

	/**
	 * Checks the token and returns the appropriate native version if possible, otherwise it returns the serialized version.
	 * @param {SyntaxKind} token
	 * @returns {ArbitraryValue}
	 */
	public marshalToken (token: SyntaxKind): ArbitraryValue {
		switch (token) {
			case SyntaxKind.NullKeyword:
				return null;
			case SyntaxKind.UndefinedKeyword:
				return undefined;
			case SyntaxKind.TrueKeyword:
				return true;
			case SyntaxKind.FalseKeyword:
				return false;
			default:
				return this.serializeToken(token);
		}
	}

	/**
	 * Serializes the given token (operand) and returns the textual representation of it.
	 * @param {SyntaxKind} token
	 * @returns {string}
	 */
	public serializeToken (token: ts.SyntaxKind | TypeNode): string {
		switch (token) {
			case SyntaxKind.ObjectKeyword:
				return "object";
			case SyntaxKind.NumberKeyword:
				return "number";
			case SyntaxKind.NeverKeyword:
				return "never";
			case SyntaxKind.BooleanKeyword:
				return "boolean";
			case SyntaxKind.AnyKeyword:
				return "any";
			case SyntaxKind.VoidKeyword:
				return "void";
			case SyntaxKind.SymbolKeyword:
				return "symbol";
			case SyntaxKind.NullKeyword:
				return "null";
			case SyntaxKind.UndefinedKeyword:
				return "undefined";
			case SyntaxKind.StringKeyword:
				return "string";
			case SyntaxKind.TrueKeyword:
				return "true";
			case SyntaxKind.FalseKeyword:
				return "false";
			case SyntaxKind.BreakKeyword:
				return "break";
			case SyntaxKind.CatchKeyword:
				return "catch";
			case SyntaxKind.CaseKeyword:
				return "case";
			case SyntaxKind.ClassKeyword:
				return "class";
			case SyntaxKind.ConstKeyword:
				return "const";
			case SyntaxKind.ContinueKeyword:
				return "continue";
			case SyntaxKind.DebuggerKeyword:
				return "debugger";
			case SyntaxKind.DefaultKeyword:
				return "default";
			case SyntaxKind.DeleteKeyword:
				return "delete";
			case SyntaxKind.DoKeyword:
				return "do";
			case SyntaxKind.ElseKeyword:
				return "else";
			case SyntaxKind.EnumKeyword:
				return "enum";
			case SyntaxKind.ExportKeyword:
				return "export";
			case SyntaxKind.ExtendsKeyword:
				return "extends";
			case SyntaxKind.FinallyKeyword:
				return "finally";
			case SyntaxKind.ForKeyword:
				return "for";
			case SyntaxKind.FunctionKeyword:
				return "function";
			case SyntaxKind.IfKeyword:
				return "if";
			case SyntaxKind.ImportKeyword:
				return "import";
			case SyntaxKind.InKeyword:
				return "in";
			case SyntaxKind.InstanceOfKeyword:
				return "instanceof";
			case SyntaxKind.NewKeyword:
				return "new";
			case SyntaxKind.ReturnKeyword:
			case SyntaxKind.ReturnStatement:
				return "return";
			case SyntaxKind.SuperKeyword:
				return "super";
			case SyntaxKind.ThisKeyword:
				return "this";
			case SyntaxKind.ThrowKeyword:
				return "throw";
			case SyntaxKind.TryKeyword:
				return "try";
			case SyntaxKind.TypeOfKeyword:
				return "typeof";
			case SyntaxKind.VarKeyword:
				return "var";
			case SyntaxKind.WithKeyword:
				return "with";
			case SyntaxKind.ImplementsKeyword:
				return "implements";
			case SyntaxKind.InterfaceKeyword:
				return "interface";
			case SyntaxKind.LetKeyword:
				return "let";
			case SyntaxKind.PackageKeyword:
				return "package";
			case SyntaxKind.PrivateKeyword:
				return "private";
			case SyntaxKind.ProtectedKeyword:
				return "protected";
			case SyntaxKind.PublicKeyword:
				return "public";
			case SyntaxKind.StaticKeyword:
				return "static";
			case SyntaxKind.YieldKeyword:
				return "yield";
			case SyntaxKind.AbstractKeyword:
				return "abstract";
			case SyntaxKind.AsKeyword:
				return "as";
			case SyntaxKind.AsyncKeyword:
				return "async";
			case SyntaxKind.AwaitKeyword:
				return "await";
			case SyntaxKind.ConstructorKeyword:
				return "constructor";
			case SyntaxKind.DeclareKeyword:
				return "declare";
			case SyntaxKind.GetKeyword:
				return "get";
			case SyntaxKind.IsKeyword:
				return "is";
			case SyntaxKind.KeyOfKeyword:
				return "keyof";
			case SyntaxKind.ModuleKeyword:
				return "module";
			case SyntaxKind.NamespaceKeyword:
				return "namespace";
			case SyntaxKind.ReadonlyKeyword:
				return "readonly";
			case SyntaxKind.RequireKeyword:
				return "require";
			case SyntaxKind.SetKeyword:
				return "set";
			case SyntaxKind.TypeKeyword:
				return "type";
			case SyntaxKind.FromKeyword:
				return "from";
			case SyntaxKind.GlobalKeyword:
				return "global";
			case SyntaxKind.OfKeyword:
				return "of";
			case SyntaxKind.MinusToken:
				return "-";
			case SyntaxKind.PlusToken:
				return "+";
			case SyntaxKind.PlusPlusToken:
				return "++";
			case SyntaxKind.MinusMinusToken:
				return "--";
			case SyntaxKind.PlusEqualsToken:
				return "+=";
			case SyntaxKind.MinusEqualsToken:
				return "-=";
			case SyntaxKind.AsteriskToken:
				return "*";
			case SyntaxKind.AtToken:
				return "@";
			case SyntaxKind.EqualsEqualsEqualsToken:
				return "===";
			case SyntaxKind.EqualsEqualsToken:
				return "==";
			case SyntaxKind.EqualsGreaterThanToken:
				return "=>";
			case SyntaxKind.EqualsToken:
				return "=";
			case SyntaxKind.AsteriskEqualsToken:
				return "*=";
			case SyntaxKind.AsteriskAsteriskEqualsToken:
				return "**=";
			case SyntaxKind.ExclamationEqualsEqualsToken:
				return "!==";
			case SyntaxKind.ExclamationEqualsToken:
				return "!=";
			case SyntaxKind.ExclamationToken:
				return "!";
			case SyntaxKind.BarBarToken:
				return "||";
			case SyntaxKind.BarToken:
				return "|";
			case SyntaxKind.BarEqualsToken:
				return "|=";
			case SyntaxKind.AmpersandAmpersandToken:
				return "&&";
			case SyntaxKind.AmpersandEqualsToken:
				return "&=";
			case SyntaxKind.AmpersandToken:
				return "&";
			case SyntaxKind.SlashEqualsToken:
				return "/=";
			case SyntaxKind.SlashToken:
				return "/";
			case SyntaxKind.LessThanSlashToken:
				return "</";
			case SyntaxKind.PercentToken:
				return "%";
			case SyntaxKind.PercentEqualsToken:
				return "%=";
			case SyntaxKind.ColonToken:
				return ":";
			case SyntaxKind.SemicolonToken:
				return ";";
			case SyntaxKind.LessThanEqualsToken:
				return "<=";
			case SyntaxKind.LessThanToken:
				return "<";
			case SyntaxKind.LessThanLessThanEqualsToken:
				return "<<=";
			case SyntaxKind.LessThanLessThanToken:
				return "<<";
			case SyntaxKind.GreaterThanEqualsToken:
				return ">=";
			case SyntaxKind.GreaterThanGreaterThanEqualsToken:
				return ">>=";
			case SyntaxKind.GreaterThanGreaterThanGreaterThanToken:
				return ">>>";
			case SyntaxKind.GreaterThanGreaterThanToken:
				return ">>";
			case SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken:
				return ">>>=";
			case SyntaxKind.GreaterThanToken:
				return ">";
			case SyntaxKind.QuestionToken:
				return "?";
			case SyntaxKind.TildeToken:
				return "~";
			case SyntaxKind.CaretToken:
				return "^";
			case SyntaxKind.CaretEqualsToken:
				return "^=";
			case SyntaxKind.AsteriskAsteriskToken:
				return "**";
			case SyntaxKind.CommaToken:
				return ",";
			case SyntaxKind.OpenBraceToken:
				return "{";
			case SyntaxKind.CloseBraceToken:
				return "}";
			case SyntaxKind.OpenParenToken:
				return "(";
			case SyntaxKind.CloseParenToken:
				return ")";
			case SyntaxKind.OpenBracketToken:
				return "[";
			case SyntaxKind.CloseBracketToken:
				return "]";
			case SyntaxKind.DotToken:
				return ".";
			case SyntaxKind.DotDotDotToken:
				return "...";
			default:
				throw new TypeError(`${this.serializeToken.name} could not serialize a token of kind ${SyntaxKind[<SyntaxKind>token]}`);
		}
	}

	/**
	 * Formats the typeArguments given to a CallExpression or a NewExpression and returns an ITypeable.
	 * @param {CallExpression|NewExpression} statement
	 * @returns {ITypeable}
	 */
	private formatTypeArguments(statement: CallExpression | NewExpression): ITypeable {
		const typeExpressions = statement.typeArguments == null ? null : statement.typeArguments.map(typeArg => this.getTypeExpression(typeArg));
		let typeExpression: TypeExpression = [];
		if (typeExpressions != null) {
			typeExpressions.forEach((typeExp, index) => {
				typeExp.forEach(part => typeExpression.push(part));
				if (index !== typeExpressions.length - 1) typeExpression.push(", ");
			});
		}
		const typeFlattened = typeExpression == null || typeExpression.length < 1 ? null : this.serializeTypeExpression(typeExpression);
		const typeBindings = typeExpression == null || typeExpression.length < 1 ? null : this.takeTypeBindings(typeExpression);

		return {
			expression: typeExpression.length < 1 ? null : typeExpression,
			flattened: typeFlattened,
			bindings: typeBindings
		};
	}

	/**
	 * Formats the callable identifier and property path (if any) of a given CallExpression or NewExpression and returns an ICallable.
	 * @param {CallExpression|NewExpression} statement
	 * @returns {ICallable}
	 */
	private formatCallable(statement: CallExpression | NewExpression): ICallable {
		const exp = statement.expression;
		let property: ArbitraryValue = null;
		let identifier: ArbitraryValue = null;
		
		if (this.isIdentifierObject(exp)) {
			identifier = this.getNameOfMember(exp, false, true);
		}

		if (this.isPropertyAccessExpression(exp)) {
			property = this.getNameOfMember(exp.expression);
			identifier = this.getNameOfMember(exp.name, false, true);
		}

		if (identifier == null) {
			throw new TypeError(`${this.formatCallable.name} could not format a CallExpression|NewExpression with an expression of kind ${SyntaxKind[exp.kind]}`);
		}
		return {
			property,
			identifier
		};
	}

	/**
	 * Formats a CallExpression into an ICallExpression.
	 * @param {CallExpression}
	 * @returns {ICallExpression}
	 */
	private formatCallExpression(statement: CallExpression): ICallExpression {
		
		return {
			...this.formatCallable(statement),
			arguments: {
				startsAt: statement.arguments.pos,
				endsAt: statement.arguments.end,
				argumentsList: this.formatArguments(statement)
			},
			type: this.formatTypeArguments(statement)
		};

	}

	/**
	 * Formats a NewExpression into an INewExpression.
	 * @param {NewExpression}
	 * @returns {INewExpression}
	 */
	private formatNewExpression(statement: NewExpression): INewExpression {
		
		return {
			...this.formatCallable(statement),			
			arguments: {
				startsAt: statement.arguments == null ? -1 : statement.arguments.pos,
				endsAt: statement.arguments == null ? -1 : statement.arguments.end,
				argumentsList: this.formatArguments(statement)
			},
			type: this.formatTypeArguments(statement)
		};

	}

	/**
	 *Formats the given Statement into an ICallExpression.
	 * @param {Statement|Expression} statement
	 * @returns {ICallExpression}
	 */
	private getCallExpression(statement: Statement|Expression): ICallExpression {
		if (this.isCallExpression(statement)) {
			return this.formatCallExpression(statement);
		}

		if (this.isExpressionStatement(statement)) {
			return this.getCallExpression(statement.expression);
		}
		throw new TypeError(`${this.getCallExpression.name} could not format a CallExpression of kind ${SyntaxKind[statement.kind]}`);
	}

	/**
	 *Formats the given Statement into an INewExpression.
	 * @param {Statement|Expression} statement
	 * @returns {INewExpression}
	 */
	private getNewExpression(statement: Statement|Expression): INewExpression {
		if (this.isNewExpression(statement)) {
			return this.formatNewExpression(statement);
		}
		throw new TypeError(`${this.getNewExpression.name} could not format a NewExpression of kind ${SyntaxKind[statement.kind]}`);
	}

	/**
	 * Gets and formats all CallExpressions associated with the given statements.
	 * These hold information such as the arguments the members are invoked with, generic type
	 * arguments and such.
	 * @param {NodeArray<Statement>} statements
	 * @returns {ICallExpression[]}
	 */
	public getCallExpressions (statements: NodeArray<Statement>): ICallExpression[] {
		const expressions: ICallExpression[] = [];

		statements.forEach(statement => {
			if (this.isCallExpression(statement) || this.isExpressionStatement(statement)) {
				expressions.push(this.getCallExpression(statement));
			}
		});
		return expressions;
	}

	/**
	 * Gets and formats all NewExpressions associated with the given statements.
	 * These hold information such as the arguments the constructor is invoked with, generic type
	 * arguments and such.
	 * @param {NodeArray<Statement>} statements
	 * @returns {INewExpression[]}
	 */
	public getNewExpressions (statements: NodeArray<Statement>): INewExpression[] {
		const expressions: INewExpression[] = [];

		statements.forEach(statement => {
			if (this.isExpressionStatement(statement) && this.isNewExpression(statement.expression)) {
				expressions.push(this.getNewExpression(statement.expression));
			}
		});
		return expressions;
	}

	/**
	 * If given an ImportDeclaration, a formatted IModuleDependency will be returned holding the relative and full import-path
	 * as well as any bindings that will live in the local scope of the given file.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @param {string} filepath
	 * @returns {IModuleDependency}
	 */
	public getImportDeclaration (statement: Statement | Declaration | Expression | Node, filepath: string): IModuleDependency {
		if (!this.isImportDeclaration(statement)) throw new Error(`Could not get an import declaration for statement that isn't an ImportDeclaration!`);

		// TODO: Remove any declaration
		const relativePath = (<any>statement.moduleSpecifier).text;
		const fullPath = join(dirname(filepath), relativePath);
		const clause = statement.importClause;

		if (clause == null || clause.namedBindings == null) {
			// A path import, e.g: "import './foo.ts'".
			return {
				relativePath,
				fullPath,
				bindings: []
			};
		}

		return {
			relativePath,
			fullPath,
			bindings: this.isNamedImports(clause.namedBindings) ? clause.namedBindings.elements.map(binding => binding.name.text) : []
		};
	}

	/**
	 * Gets the member name for call expression.
	 * @param {CallExpression} statement
	 * @returns {string}
	 */
	private getCallExpressionMemberName (statement: CallExpression): string {
		if (this.isIdentifierObject(statement.expression)) return statement.expression.text;
		throw new TypeError(`${this.getCallExpressionMemberName.name} could not get the name for an expression!`);
	}

	/**
	 * Gets all variable assignments (if any) that occurs in the given array of statements
	 * and returns them in an AssignmentMap.
	 * @param {NodeArray<Statement>} statements
	 * @returns {AssignmentMap}
	 */
	public getVariableAssignments (statements: NodeArray<Statement>): AssignmentMap {
		const assignmentMap: AssignmentMap = {};
		for (const statement of statements) {
			if (this.isVariableDeclaration(statement)) {
				const declarations = statement.declarationList.declarations;
				declarations.forEach(declaration => {

					if (this.isIdentifierObject(declaration.name)) {
						const name = declaration.name.text;
						const valueExpression = declaration.initializer == null ? null : this.getInitializedValue(declaration.initializer);
						const startsAt = declaration.pos;
						const endsAt = declaration.end;
						const typeExpression = declaration.type == null ? null : this.getTypeExpression(declaration.type);
						const typeFlattened = typeExpression == null ? null : this.serializeTypeExpression(typeExpression);
						const typeBindings = typeExpression == null ? null : this.takeTypeBindings(typeExpression);

						assignmentMap[name] = {
							name,
							value: {
								expression: valueExpression,
								// TODO: Compute this!
								resolved: ""
							},
							startsAt,
							endsAt,
							type: {
								expression: typeExpression,
								flattened: typeFlattened,
								bindings: typeBindings
							}
						};
					}
				});
			}
		}
		return assignmentMap;
	}

	/**
	 * Gets all class declarations (if any) that occurs in the given array of statements
	 * and returns them as an array.
	 * @param {NodeArray<Statement>} statements
	 * @param {string} filepath
	 * @param {string} code
	 * @returns {IClassDeclaration[]}
	 */
	public getClassDeclarations (statements: NodeArray<Statement>, filepath: string, code: string): IClassDeclaration[] {
		const declarations: IClassDeclaration[] = [];
		for (const statement of statements) {
			const declaration = this.isClassDeclaration(statement) ? this.getClassDeclaration(statement, filepath, code) : null;
			if (declaration != null) declarations.push(declaration);
		}
		return declarations;
	}

	/**
	 * Gets and returns all ImportDeclarations (if any) that occur in the given file and array of statements.
	 * @param {NodeArray<Statement>} statements
	 * @param {string} filepath
	 * @returns {IModuleDependency[]}
	 */
	public getImportDeclarations (statements: NodeArray<Statement>, filepath: string): IModuleDependency[] {
		const declarations: IModuleDependency[] = [];
		for (const statement of statements) {
			if (this.isImportDeclaration(statement)) {
				const declaration = this.getImportDeclaration(statement, filepath);
				declarations.push(declaration);
			}
		}
		return declarations;
	}

	/**
	 * Gets all ExportDeclarations (if any) that occur in the given array of statements and returns a Set
	 * of all the identifiers that are being exported.
	 * @param {NodeArray<Statement>} statements
	 * @returns {Set<string>}
	 */
	public getExportDeclarations (statements: NodeArray<Statement>): Set<string> {
		const declarations: Set<string> = new Set();
		for (const statement of statements) {
			if (this.isExportDeclaration(statement)) {
				if (statement.exportClause != null) {
					statement.exportClause.elements.forEach(element => declarations.add(element.name.text));
				}
			}
		}
		return declarations;
	}


	/**
	 * Checks and formats the initialization value of the given statement (if any) and returns it.
	 * Since such a statement can be a combination of multiple operations and identifiers, an array of statements will be
	 * returned.
	 * @param {Statement|Expression|Node} rawStatement
	 * @returns {NullableInitializationValue}
	 */
	public getInitializedValue (rawStatement: Statement | Expression | Node): InitializationValue {

		if (this.isNumericLiteral(rawStatement)) {
			const marshalled = this.marshaller.marshal<string, number>(rawStatement.text);
			return [marshalled];
		}

		if (this.isStringLiteral(rawStatement)) {
			const marshalled = this.marshaller.marshal<string, ArbitraryValue>(rawStatement.text);
			return [marshalled];
		}

		if (this.isNoSubstitutionTemplateLiteral(rawStatement)) {
			const marshalled = this.marshaller.marshal<string, string>(rawStatement.text);
			return [marshalled];
		}

		if (this.isTemplateHead(rawStatement) || this.isTemplateTail(rawStatement)) {
			const marshalled = this.marshaller.marshal<string, string>(rawStatement.text, "");
			return [marshalled];
		}

		if (this.isTemplateSpan(rawStatement)) {
			const head = this.getInitializedValue(rawStatement.expression);
			const tail = this.getInitializedValue(rawStatement.literal);
			const headNormalized: InitializationValue = [];
			head.forEach(part => {
				if (part instanceof BindingIdentifier) {
					headNormalized.push("${");
					headNormalized.push(part);
					headNormalized.push("}");
				}
				else headNormalized.push(part);
			});

			return [...headNormalized, ...tail];
		}

		if (this.isBinaryExpression(rawStatement)) {
			const arr: InitializationValue = [];

			const left = this.getInitializedValue(rawStatement.left);
			const operator = this.getInitializedValue(rawStatement.operatorToken);
			const right = this.getInitializedValue(rawStatement.right);

			left.forEach(item => arr.push(item));
			operator.forEach(item => arr.push(item));
			right.forEach(item => arr.push(item));
			return arr;
		}

		if (this.isConditionalExpression(rawStatement)) {
			const arr: InitializationValue = [];
			const condition = this.getInitializedValue(rawStatement.condition);
			const question = this.getInitializedValue(rawStatement.questionToken);
			const colon = this.getInitializedValue(rawStatement.colonToken);
			const whenTrue = this.getInitializedValue(rawStatement.whenTrue);
			const whenFalse = this.getInitializedValue(rawStatement.whenFalse);

			condition.forEach(item => arr.push(item));
			question.forEach(item => arr.push(item));
			whenTrue.forEach(item => arr.push(item));
			colon.forEach(item => arr.push(item));
			whenFalse.forEach(item => arr.push(item));
			return arr;
		}

		if (this.isCallExpression(rawStatement) || this.isNewExpression(rawStatement)) {
			const name = this.getNameOfMember(rawStatement.expression);
			const arr: InitializationValue = [];
			if (this.isNewExpression(rawStatement)) arr.push("new ");
			arr.push(name);
			arr.push("(");
			const args = rawStatement.arguments;
			if (args != null) args.forEach((arg, index) => {
				const value = this.getInitializedValue(arg);
				value.forEach(item => {
					arr.push(item);
					if (index !== args.length - 1) arr.push(",");
				});
			});
			arr.push(")");
			return arr;
		}

		if (this.isObjectLiteralExpression(rawStatement)) {
			const obj: InitializationValue = ["{"];
			rawStatement.properties.forEach((property, index) => {

				if (this.isSpreadAssignment(property)) {
					obj.push("...");
					const exp = this.getInitializedValue(property.expression);
					exp.forEach(item => obj.push(item));
				} else {
					if (property.name == null) return;

					let value = this.isPropertyAssignment(property) ? this.getInitializedValue(property.initializer) : null;
					if (property.name == null) return;

					// Check if the property name is computed (.eg. [key]: "foo").
					if (this.isComputedPropertyName(property.name)) obj.push("[");

					// Check if the property name is computed and a call expression (.eg. [getKey()]: "foo").
					if (this.isComputedPropertyName(property.name) && this.isCallExpression(property.name.expression)) {
						const callExpression = this.getInitializedValue(property.name.expression);
						callExpression.forEach(item => obj.push(item));
					}

					else {
						// Otherwise, just push the name of it.
						obj.push(this.getNameOfMember(property.name, true));
					}

					if (this.isComputedPropertyName(property.name)) obj.push("]");
					obj.push(":");
					if (value == null) obj.push(value);
					else value.forEach(item => obj.push(item));
				}
				if (index !== rawStatement.properties.length - 1) obj.push(",");
			});
			obj.push("}");
			return obj;
		}

		if (this.isArrayLiteralExpression(rawStatement)) {
			const arr: InitializationValue = ["["];
			rawStatement.elements.forEach((element, index) => {
				const value = this.getInitializedValue(element);
				value.forEach(part => arr.push(part));
				const lastPart = value[value.length - 1];
				if (index !== rawStatement.elements.length - 1 && lastPart !== "...") arr.push(",");
			});

			arr.push("]");
			return arr;
		}

		if (this.isTemplateExpression(rawStatement)) {

			let values: InitializationValue = [...this.getInitializedValue(rawStatement.head)];

			rawStatement.templateSpans.forEach(span => {
				const content = this.getInitializedValue(span);
				// Remove empty strings from the contents and add everything else to the value array.
				content.filter(item => !(typeof item === "string" && item.length < 1)).forEach(checkedItem => values.push(checkedItem));
			});


			return ["\`", ...values, "\`"];
		}

		if (this.isPropertyAccessExpression(rawStatement)) {
			return [this.getNameOfMember(rawStatement)];
		}

		if (this.isElementAccessExpression(rawStatement)) {
			return [this.getNameOfMember(rawStatement)];
		}

		if (this.isParameterDeclaration(rawStatement)) {
			const name = this.getNameOfMember(rawStatement.name);
			const initializer = rawStatement.initializer == null ? null : this.getInitializedValue(rawStatement.initializer);
			const arr: InitializationValue = [name];
			if (initializer != null) {
				arr.push("=");
				initializer.forEach(item => arr.push(item));
			}
			return arr;
		}

		if (this.isArrowFunction(rawStatement)) {
			const arr: InitializationValue = ["("];
			const equalsGreaterThanToken = this.getInitializedValue(rawStatement.equalsGreaterThanToken);
			const body = this.getInitializedValue(rawStatement.body);

			rawStatement.parameters.forEach((parameter, index) => {
				const value = this.getInitializedValue(parameter);
				value.forEach(item => arr.push(item));
				if (index !== rawStatement.parameters.length - 1) arr.push(",");
			});

			arr.push(")");
			equalsGreaterThanToken.forEach(item => arr.push(item));
			body.forEach(item => arr.push(item));
			return arr;
		}

		if (this.isFunctionExpression(rawStatement)) {
			const arr: InitializationValue = ["function"];
			const body = this.getInitializedValue(rawStatement.body);

			if (rawStatement.name != null) {
				arr.push(this.getNameOfMember(rawStatement.name));
			}

			arr.push("(");

			rawStatement.parameters.forEach((parameter, index) => {
				const value = this.getInitializedValue(parameter);
				value.forEach(item => arr.push(item));
				if (index !== rawStatement.parameters.length - 1) arr.push(",");
			});
			arr.push(")");
			arr.push("{");
			body.forEach(item => arr.push(item));
			arr.push("}");
			return arr;
		}

		if (this.isBlockDeclaration(rawStatement)) {
			const arr: InitializationValue = [];
			rawStatement.statements.forEach(statement => {
				const value = this.getInitializedValue(statement);
				value.forEach(item => arr.push(item));
			});
			return arr;
		}

		if (this.isSpreadElement(rawStatement)) {
			return ["...", ...this.getInitializedValue(rawStatement.expression)];
		}

		if (this.isParenthesizedExpression(rawStatement)) {
			return ["(", ...this.getInitializedValue(rawStatement.expression), ")"];
		}

		if (this.isReturnStatement(rawStatement)) {
			return [this.marshalToken(rawStatement.kind), ...(rawStatement.expression == null ? [] : this.getInitializedValue(rawStatement.expression))];
		}

		if (this.isTokenObject(rawStatement)) {
			return [this.marshalToken(rawStatement.kind)];
		}

		if (this.isIdentifierObject(rawStatement)) {
			return [this.getNameOfMember(rawStatement, true)];
		}

		throw new TypeError(`${this.getInitializedValue.toString()} could not extract a value for a statement! of kind ${(<Identifier>rawStatement).kind == null ? "unknown" : SyntaxKind[(<Identifier>rawStatement).kind]}`);
	}

	/**
	 * Computes the mot probable native type of the given string.
	 * @param {string} text
	 * @returns {string}
	 */
	private mostProbableTypeOf (text: string): string {
		return typeof this.marshaller.marshal<string, ArbitraryValue>(text);
	}

	/**
	 * Returns the path of an expression.
	 * @param {ElementAccessExpression|Identifier|Expression}
	 * @returns {ArbitraryValue[]}
	 */
	private getPathOfExpression(expression: ElementAccessExpression | Identifier | Expression): ArbitraryValue[] {
		return [this.getNameOfMember(expression, true, true)];
	}

	/**
	 * Takes the base identifier of an expression. For instance, if it has a path, it returns the base name of it.
	 * @param {ArbitraryValue} expression
	 * @returns {string}
	 */
	private takeBase (expression: ArbitraryValue): string {
		return expression instanceof BindingIdentifier ? expression.name : expression == null ? "" : expression.toString();
	}

	/**
	 * Takes the path identifier of an expression. For instance, if it has a path, it returns it.
	 * @param {ArbitraryValue} expression
	 * @returns {ArbitraryValue[]}
	 */
	private takePath (expression: ArbitraryValue): ArbitraryValue[] {
		return expression instanceof BindingIdentifier && expression.path != null ? expression.path : [];
	}

	/**
	 * Detects the name/key of a member of something (for example, an ObjectLiteral). If the second argument is truthy,
	 * the name may also be a non-string entity.
	 * @param {DeclarationName} name
	 * @param {boolean} [allowNonStringNames=false]
	 * @param {boolean} [forceNoBindingIdentifier=false]
	 * @returns {ArbitraryValue}
	 */
	private getNameOfMember(name: DeclarationName | Expression, allowNonStringNames: boolean = false, forceNoBindingIdentifier: boolean = false): ArbitraryValue {

		if (this.isComputedPropertyName(name)) {
			if (this.isPropertyName(name.expression)) {
				if (this.isComputedPropertyName(name.expression)) return this.getNameOfMember(name.expression, allowNonStringNames, false);
				return this.getNameOfMember(name.expression, allowNonStringNames, false);
			}

			if (this.isCallExpression(name.expression)) {
				return this.getNameOfMember(name.expression.expression, allowNonStringNames, forceNoBindingIdentifier);
			}

			throw new TypeError(`${this.getNameOfMember.name} could not compute the name of a ${SyntaxKind[name.kind]}: It wasn't a PropertyName or a CallExpression. Instead, it was a ${SyntaxKind[name.expression.kind]}`);
		}

		if (this.isIdentifierObject(name)) {
			const marshalled = this.marshaller.marshal<string, ArbitraryValue>(name.text, allowNonStringNames ? undefined : "");

			if (name.parent != null && (this.isPropertyAssignment(name.parent) || this.isParameterDeclaration(name.parent))) {
				// Then this is the key of a property-assignment. We already know it isn't computed, so it can't be an identifier to another variable.
				return marshalled;
			}

			// Otherwise, it most likely is a reference to a variable or other Identifier unless it is a global symbol like "Infinity" or "Nan".
			if (this.mostProbableTypeOf(name.text) === "string" && !forceNoBindingIdentifier) {
				return new BindingIdentifier(name.text, null);
			}
			return marshalled;
		}

		if (this.isFirstLiteralToken(name)) {
			return this.marshaller.marshal<string, ArbitraryValue>(name.text, allowNonStringNames ? undefined : "");
		}

		if (this.isStringLiteral(name)) {
			return name.text;
		}

		if (this.isThisKeyword(name)) {
			return "this";
		}

		if (this.isPropertyAccessExpression(name)) {
			const baseName = this.getNameOfMember(name.expression, false, false);
			const baseNameStringified = this.takeBase(baseName);
			const pathStringified = this.takePath(baseName);

			const path = name.name == null ? null : [...pathStringified, ...this.getPathOfExpression(name.name)].filter(part => {
				if (typeof part === "string") return part.length > 0;
				return part != null;
			});
			
			return new BindingIdentifier(baseNameStringified, path);
		}

		if (this.isCallExpression(name)) {
			return this.getNameOfMember(name.expression, allowNonStringNames, forceNoBindingIdentifier);
		}

		if (this.isElementAccessExpression(name)) {
			const baseName = this.getNameOfMember(name.expression, false, false);
			const baseNameStringified = this.takeBase(baseName);
			const pathStringified = this.takePath(baseName);

			const path = name.argumentExpression == null ? null : [...pathStringified, ...this.getPathOfExpression(name.argumentExpression)].filter(part => {
				if (typeof part === "string") return part.length > 0;
				return part != null;
			});
			
			return new BindingIdentifier(baseNameStringified, path);
		}

		throw new TypeError(`${this.getNameOfMember.name} could not compute the name of a ${SyntaxKind[name.kind]}.`);
	}

	/**
	 * Flattens and returns an initialization value.
	 * @param {InitializationValue} value
	 * @param {boolean} [stringifyIdentifiers=false]
	 * @returns {string|null}
	 */
	public join (value: InitializationValue, stringifyIdentifiers: boolean = false): string | null {
		let str = "";
		value.map(item => {
			const trimmed = typeof item === "string" ? item.trim() : stringifyIdentifiers && item instanceof BindingIdentifier ? item.name : item;
			const whitespaced = trimmed === "new" ? `${trimmed} ` : trimmed;
			str += `${whitespaced}`;
		});
		return str;
	}

	/**
	 * Tokenizes the type information from the given statement and returns a TypeExpression.
	 * @param {ParameterDeclaration|TypeAliasDeclaration|TypeNode} statement
	 * @returns {TypeExpression}
	 */
	private getTypeExpression (statement: ParameterDeclaration | TypeAliasDeclaration | TypeNode): TypeExpression {


		if (this.isTypeNode(statement)) {
			if ((this.isTypeReferenceNode(statement) || this.isTypeReference(statement)) && this.isIdentifierObject(statement.typeName)) {
				const name = statement.typeName.text;
				let typeArguments: TypeExpression | null = null;
				const typeArgs = statement.typeArguments;

				if (typeArgs != null) {
					typeArgs.forEach((typeArgument, index) => {
						const value = this.getTypeExpression(typeArgument);
						value.forEach(part => {
							if (typeArguments == null) typeArguments = [];
							typeArguments.push(part);
							if (index !== typeArgs.length - 1) typeArguments.push(", ");
						});
					});
				}
				return [{name, typeArguments}];
			}

			if (this.isArrayTypeNode(statement)) {
				return [...this.getTypeExpression(statement.elementType), "[", "]"];
			}

			if (this.isTupleTypeNode(statement)) {
				const exp: TypeExpression = [];
				exp.push("[");

				statement.elementTypes.forEach((type, index) => {
					const value = this.getTypeExpression(type);
					value.forEach(part => exp.push(part));
					if (index !== statement.elementTypes.length - 1) exp.push(", ");
				});
				exp.push("]");
				return exp;
			}

			if (this.isIntersectionTypeNode(statement)) {
				const exp: TypeExpression = [];

				statement.types.forEach((intersectionType, index) => {
					const value = this.getTypeExpression(intersectionType);

					value.forEach(part => exp.push(part));
					if (index !== statement.types.length - 1) exp.push(" & ");
				});
				return exp;
			}

			if (this.isUnionTypeNode(statement)) {
				const exp: TypeExpression = [];

				statement.types.forEach((unionType, index) => {
					const value = this.getTypeExpression(unionType);

					value.forEach(part => exp.push(part));
					if (index !== statement.types.length - 1) exp.push("|");
				});
				return exp;
			}

			return [this.serializeToken(statement.kind)];
		}

		if (this.isTypeLiteralNode(statement)) {
			const exp: TypeExpression = ["{"];

			statement.members.forEach((member, index) => {

				if (this.isIndexSignatureDeclaration(member)) {
					exp.push("[");

					member.parameters.forEach(parameter => {
						exp.push(<string>this.getNameOfMember(parameter.name, false, true));
						if (parameter.type != null) {
							exp.push(": ");
							const type = this.getTypeExpression(parameter.type);
							type.forEach(part => exp.push(part));
						}
						exp.push("]");

					});
					if (member.type != null) {
						exp.push(": ");
						const type = this.getTypeExpression(member.type);
						type.forEach(part => exp.push(part));
					}
				}

				if (this.isPropertySignature(member)) {
					const name = <string>this.getNameOfMember(member.name, false, true);
					const type = member.type == null ? null : this.getTypeExpression(member.type);
					exp.push(name);

					if (member.questionToken != null) {
						exp.push(this.serializeToken(member.questionToken.kind));
					}
					if (type != null) {
						exp.push(": ");
						type.forEach(part => exp.push(part));
					}
				}

				if (index !== statement.members.length - 1) exp.push(", ");

			});
			exp.push("}");
			return exp;
		}

		if (this.isTypeReference(statement) && this.isIdentifierObject(statement.typeName)) {
			const name = statement.typeName.text;
			let typeArguments: TypeExpression | null = null;
			const typeArgs = statement.typeArguments;
			if (typeArgs != null) {
				typeArgs.forEach((typeArgument, index) => {
					const value = this.getTypeExpression(typeArgument);
					value.forEach(part => {
						if (typeArguments == null) typeArguments = [];
						typeArguments.push(part);
						if (index !== typeArgs.length - 1) typeArguments.push(", ");
					});
				});
			}
			return [{name, typeArguments}];
		}

		if (statement.type != null) return this.getTypeExpression(statement.type);
		throw new TypeError(`${this.getTypeExpression.name} could not retrieve the type information for a statement of kind ${SyntaxKind[statement.kind]}`);
	}

	/**
	 * Takes all ITypeBindings from a TypeExpression and returns an array of them.
	 * @param {TypeExpression} expression
	 * @param {boolean} [deep=false]
	 * @returns {ITypeBinding[]}
	 */
	private takeTypeBindings (expression: TypeExpression, deep: boolean = false): ITypeBinding[] {
		const bindings: ITypeBinding[] = [];

		expression.forEach(token => {
			if (this.isTypeBinding(token)) {
				bindings.push(token);

				if (token.typeArguments != null && deep) {
					this.takeTypeBindings(token.typeArguments, deep).forEach(typeBinding => bindings.push(typeBinding));
				}
			}
		});
		return bindings;
	}


	/**
	 * Formats and returns a string representation of a type.
	 * @param {TypeExpression} expression
	 * @returns {string}
	 */
	private serializeTypeExpression (expression: TypeExpression): string {
		let statement: string = "";
		expression.forEach(token => {
			if (this.isTypeBinding(token)) {
				statement += token.name;
				if (token.typeArguments != null) {
					statement += `<${this.serializeTypeExpression(token.typeArguments)}>`;
				}
			} else {
				statement += `${token}`;
			}
		});
		return statement;
	}

	/**
	 * Takes a PropertyDeclaration and returns an IPropDeclaration.
	 * @param {PropertyDeclaration} declaration
	 * @returns {IPropDeclaration}
	 */
	private formatPropertyDeclaration (declaration: PropertyDeclaration): IPropDeclaration {
		const startsAt = declaration.pos;
		const endsAt = declaration.end;
		const name = <string>this.getNameOfMember(declaration.name, false, true);
		const typeExpression = declaration.type == null ? null : this.getTypeExpression(declaration.type);
		const typeFlattened = typeExpression == null ? null : this.serializeTypeExpression(typeExpression);
		const typeBindings = typeExpression == null ? null : this.takeTypeBindings(typeExpression);
		const decorators = declaration.decorators == null ? [] : declaration.decorators.map(decorator => <string>this.getNameOfMember(decorator.expression, false, true));
		const valueExpression = declaration.initializer == null ? null : this.getInitializedValue(declaration.initializer);
		// TODO: Resolve value!
		const valueResolved = "";
		return {
			startsAt,
			endsAt,
			name,
			type: {
				expression: typeExpression,
				flattened: typeFlattened,
				bindings: typeBindings
			},
			decorators,
			value: {
				expression: valueExpression,
				resolved: valueResolved
			}
		};
	}

	/**
	 * Takes a PropertyDeclaration and returns an IPropDeclaration.
	 * @param {NodeArray<HeritageClause>} clauses
	 * @returns {IPropDeclaration}
	 */
	private formatHeritageClauses (clauses: NodeArray<HeritageClause>): IHeritage {
		const obj: IHeritage = {extendsClass: null, implementsInterfaces: []};

		clauses.forEach(clause => {

			if (this.isExtendsClause(clause)) {
				// There can only be one extended class.
				const [classIdentifier] = clause.types;
				const [extendsClass] = this.getTypeExpression(classIdentifier);
				if (this.isTypeBinding(extendsClass)) {
					obj.extendsClass = extendsClass;
				}
			}

			if (this.isImplementsClause(clause)) {
				clause.types.forEach(identifier => {
					const expression = this.getTypeExpression(identifier);
					expression.forEach(part => {
						if (this.isTypeBinding(part)) {
							obj.implementsInterfaces.push(part);
						}
					});
				});
			}
		});
		return obj;
	}

	/**
	 * Formats a concrete ParameterDeclaration and returns an IParameter.
	 * @param {ParameterDeclaration} parameter
	 * @returns {IParameter}
	 */
	private formatParameter (parameter: ParameterDeclaration): IParameter {
		const startsAt = parameter.pos;
		const endsAt = parameter.end;
		const name = <string>this.getNameOfMember(parameter.name, false, true);
		const typeExpression = parameter.type == null ? null : this.getTypeExpression(parameter);
		const typeFlattened = typeExpression == null ? null : this.serializeTypeExpression(typeExpression);
		const typeBindings = typeExpression == null ? null : this.takeTypeBindings(typeExpression);
		const valueExpression = parameter.initializer != null ? this.getInitializedValue(parameter.initializer) : null;
		// TODO: Compute this!
		const valueResolved = "";
		return {
			startsAt,
			endsAt,
			name,
			type: {
				expression: typeExpression,
				flattened: typeFlattened,
				bindings: typeBindings
			},
			value: {
				expression: valueExpression,
				resolved: valueResolved
			}
		};
	}

	/**
	 * Formats a concrete ParameterDeclaration and returns an IArgument.
	 * @param {Expression} argument
	 * @returns {IArgument}
	 */
	private formatArgument (argument: Expression): IArgument {
		const startsAt = argument.pos;
		const endsAt = argument.end;
		const valueExpression = this.getInitializedValue(argument);
		// TODO: Compute this!
		const valueResolved = "";
		return {
			startsAt,
			endsAt,
			value: {
				expression: valueExpression,
				resolved: valueResolved
			}
		};
	}

	/**
	 * Takes the parameters from a ConstructorDeclaration or a MethodDeclaration and returns an array of IParameters.
	 * @param {ConstructorDeclaration | MethodDeclaration} declaration
	 * @returns {IParameter[]}
	 */
	private formatParameters (declaration: ConstructorDeclaration | MethodDeclaration): IParameter[] {
		return declaration.parameters.map(param => this.formatParameter(param));
	}

	/**
	 * Takes the arguments from a CallExpression and returns an array of IArguments.
	 * @param {CallExpression} declaration
	 * @returns {IArgument[]}
	 */
	private formatArguments (declaration: CallExpression|NewExpression): IArgument[] {
		return declaration.arguments == null ? [] : declaration.arguments.map(arg => this.formatArgument(arg));
	}

	/**
	 * Takes a ConstructorDeclaration or a MethodDeclaration and returns an IMemberDeclaration.
	 * @param {ConstructorDeclaration|MethodDeclaration} declaration
	 * @param {string} fileContents
	 * @returns {IMemberDeclaration}
	 */
	private formatCallableMemberDeclaration (declaration: ConstructorDeclaration | MethodDeclaration, fileContents: string): IMemberDeclaration & IParametersable {
		const startsAt = declaration.pos;
		const endsAt = declaration.end;
		const body = declaration.body;
		const argumentsStartsAt = declaration.parameters.pos;
		const argumentsEndsAt = declaration.parameters.end;

		const bodyStartsAt = body == null ? -1 : body.pos;
		const bodyEndsAt = body == null ? -1 : body.end;
		const contents = fileContents.slice(startsAt, endsAt);
		const bodyContents = body == null ? null : fileContents.slice(bodyStartsAt, bodyEndsAt);

		return {
			startsAt,
			endsAt,
			contents,
			body: {
				startsAt: bodyStartsAt,
				endsAt: bodyEndsAt,
				contents: bodyContents
			},
			parameters: {
				startsAt: argumentsStartsAt,
				endsAt: argumentsEndsAt,
				parametersList: this.formatParameters(declaration)
			}
		};
	}

	/**
	 * Takes a ConstructorDeclaration and returns an IConstructorDeclaration.
	 * @param {ConstructorDeclaration} declaration
	 * @param {string} fileContents
	 * @returns {IConstructorDeclaration}
	 */
	private formatConstructorDeclaration (declaration: ConstructorDeclaration, fileContents: string): IConstructorDeclaration {
		const name = "constructor";
		return {...this.formatCallableMemberDeclaration(declaration, fileContents), ...{name}};
	}

	/**
	 * Takes a MethodDeclaration and returns an IMethodDeclaration.
	 * @param {MethodDeclaration} declaration
	 * @param {string} fileContents
	 * @returns {IMethodDeclaration}
	 */
	private formatMethodDeclaration (declaration: MethodDeclaration, fileContents: string): IMethodDeclaration {
		const name = <string>this.getNameOfMember(declaration.name, false, true);
		let returnStatementStartsAt: number = -1;
		let returnStatementEndsAt: number = -1;
		let returnStatementContents: string | null = null;

		if (declaration.body != null && declaration.body.statements != null) {
			declaration.body.statements.forEach(bodyStatement => {

				if (this.isReturnStatement(bodyStatement)) {
					if (bodyStatement.expression != null) {
						returnStatementStartsAt = bodyStatement.expression.pos;
						returnStatementEndsAt = bodyStatement.expression.end;
						returnStatementContents = fileContents.slice(returnStatementStartsAt, returnStatementEndsAt);
					}
				}
			});
		}

		return {
			...this.formatCallableMemberDeclaration(declaration, fileContents),
			...{name, returnStatementStartsAt, returnStatementEndsAt, returnStatementContents}
		};
	}

	/**
	 * Gets a class declaration, including its methods, positions, which class it derives from,
	 * props and constructor parameters.
	 * @param {Statement|Declaration|Expression|Node} statement
	 * @param {string} filepath
	 * @param {string} fileContents
	 * @returns {IClassDeclaration}
	 */
	public getClassDeclaration (statement: ClassDeclaration, filepath: string, fileContents: string): IClassDeclaration | null {
		if (statement.name == null) return null;

		const className = statement.name.text;
		const classDeclarationStartsAt = statement.pos;
		const classDeclarationEndsAt = statement.end;
		const classBodyStartsAt = statement.members.pos;
		const classBodyEndsAt = statement.members.end;
		const fullClassContents = fileContents.slice(classDeclarationStartsAt, classDeclarationEndsAt);
		const bodyClassContents = fileContents.slice(classBodyStartsAt, classBodyEndsAt);

		const declaration: IClassDeclaration = {
			name: className,
			filepath,
			methods: {},
			heritage: statement.heritageClauses == null ? null : this.formatHeritageClauses(statement.heritageClauses),
			constructor: null,
			startsAt: classDeclarationStartsAt,
			endsAt: classDeclarationEndsAt,
			contents: fullClassContents,
			body: {
				startsAt: classBodyStartsAt,
				endsAt: classBodyEndsAt,
				contents: bodyClassContents
			},
			props: {}
		};

		statement.members.forEach(member => {

			if (this.isPropertyDeclaration(member)) {
				const formatted = this.formatPropertyDeclaration(member);
				declaration.props[formatted.name] = formatted;
			}

			else if (this.isConstructorDeclaration(member)) {
				declaration.constructor = this.formatConstructorDeclaration(member, fileContents);
			}

			else if (this.isMethodDeclaration(member)) {
				const formatted = this.formatMethodDeclaration(member, fileContents);
				declaration.methods[formatted.name] = formatted;
			}

			else throw new TypeError(`${this.getClassDeclaration.name} didn't understand a class member of type ${SyntaxKind[member.kind]}`);
		});

		return declaration;
	}

	// /**
	//  * Finds a free enum ordinal value. Free meaning that no other member of the enumeration is initialized to that value.
	//  * @param {Set<number>} taken
	//  * @returns {number}
	//  */
	// private findFreeEnumIntegerValue (taken: Set<number>): number {
	// 	const sorted = [...taken].sort();
	//
	// 	for (let i = 0; i < sorted.length; i++) {
	// 		if (taken.has(i)) continue;
	// 		return i;
	// 	}
	// 	return sorted.length;
	// }
	//
	// /**
	//  * Walks through an enumeration and checks the associated ordinal values.
	//  * @param {EnumDeclaration} statement
	//  * @returns NullableInitializationValue}
	//  */
	// private getInitializedValuesForEnum (statement: EnumDeclaration): NullableInitializationValue {
	// 	const props: { [key: string]: NullableInitializationValue } = {};
	// 	const taken: Set<number> = new Set();
	// 	statement.members.forEach(member => {
	// 		// TODO: Typescript doesn't think that a 'text' key exists here. Why?
	// 		const value = (<Identifier>member.name).text;
	// 		const initializer = member.initializer;
	// 		// TODO: Remove any declaration.
	// 		const integerValue = initializer == null ? this.findFreeEnumIntegerValue(taken) : parseInt((<any>initializer).text);
	//
	// 		taken.add(integerValue);
	//
	// 		if (value != null) props[value] = [integerValue];
	// 	});
	// 	return [props];
	// }

}